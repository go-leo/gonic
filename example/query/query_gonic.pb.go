// Code generated by protoc-gen-gonic. DO NOT EDIT.

package query

import (
	context "context"
	gin "github.com/gin-gonic/gin"
	gonic "github.com/go-leo/gonic"
	httpbody "google.golang.org/genproto/googleapis/api/httpbody"
	protojson "google.golang.org/protobuf/encoding/protojson"
	proto "google.golang.org/protobuf/proto"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
)

type BoolQueryGonicService interface {
	BoolQuery(ctx context.Context, request *BoolQueryRequest) (*httpbody.HttpBody, error)
}

func AppendBoolQueryGonicRoute[Router gin.IRoutes](router Router, service BoolQueryGonicService, opts ...gonic.Option) Router {
	options := gonic.NewOptions(opts...)
	handler := boolQueryGonicHandler{
		service: service,
		decoder: boolQueryGonicRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: boolQueryGonicResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            gonic.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Match([]string{"GET"}, "/v1/bool", gonic.Chain(handler.BoolQuery(), options.Middlewares()...)...)
	return router
}

type boolQueryGonicHandler struct {
	service                 BoolQueryGonicService
	decoder                 boolQueryGonicRequestDecoder
	encoder                 boolQueryGonicResponseEncoder
	errorEncoder            gonic.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback gonic.OnValidationErrCallback
}

func (h boolQueryGonicHandler) BoolQuery() gin.HandlerFunc {
	return gin.HandlerFunc(func(ctx *gin.Context) {
		in, err := h.decoder.BoolQuery(ctx)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := gonic.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		out, err := h.service.BoolQuery(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := h.encoder.BoolQuery(ctx, out); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
	})
}

type boolQueryGonicRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder boolQueryGonicRequestDecoder) BoolQuery(ctx *gin.Context) (*BoolQueryRequest, error) {
	r := ctx.Request
	req := &BoolQueryRequest{}
	ok, err := gonic.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	queries := r.URL.Query()
	var queryErr error
	req.Bool, queryErr = gonic.DecodeForm[bool](queryErr, queries, "bool", gonic.GetBool)
	req.OptBool, queryErr = gonic.DecodeForm[*bool](queryErr, queries, "opt_bool", gonic.GetBoolPtr)
	req.WrapBool, queryErr = gonic.DecodeForm[*wrapperspb.BoolValue](queryErr, queries, "wrap_bool", gonic.GetBoolValue)
	req.ListBool, queryErr = gonic.DecodeForm[[]bool](queryErr, queries, "list_bool", gonic.GetBoolSlice)
	req.ListWrapBool, queryErr = gonic.DecodeForm[[]*wrapperspb.BoolValue](queryErr, queries, "list_wrap_bool", gonic.GetBoolValueSlice)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type boolQueryGonicResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gonic.ResponseTransformer
}

func (encoder boolQueryGonicResponseEncoder) BoolQuery(ctx *gin.Context, resp *httpbody.HttpBody) error {
	return gonic.EncodeHttpBody(ctx, ctx.Writer, resp)
}

type Int32QueryGonicService interface {
	Int32Query(ctx context.Context, request *Int32QueryRequest) (*httpbody.HttpBody, error)
}

func AppendInt32QueryGonicRoute[Router gin.IRoutes](router Router, service Int32QueryGonicService, opts ...gonic.Option) Router {
	options := gonic.NewOptions(opts...)
	handler := int32QueryGonicHandler{
		service: service,
		decoder: int32QueryGonicRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: int32QueryGonicResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            gonic.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Match([]string{"GET"}, "/v1/int32", gonic.Chain(handler.Int32Query(), options.Middlewares()...)...)
	return router
}

type int32QueryGonicHandler struct {
	service                 Int32QueryGonicService
	decoder                 int32QueryGonicRequestDecoder
	encoder                 int32QueryGonicResponseEncoder
	errorEncoder            gonic.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback gonic.OnValidationErrCallback
}

func (h int32QueryGonicHandler) Int32Query() gin.HandlerFunc {
	return gin.HandlerFunc(func(ctx *gin.Context) {
		in, err := h.decoder.Int32Query(ctx)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := gonic.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		out, err := h.service.Int32Query(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := h.encoder.Int32Query(ctx, out); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
	})
}

type int32QueryGonicRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder int32QueryGonicRequestDecoder) Int32Query(ctx *gin.Context) (*Int32QueryRequest, error) {
	r := ctx.Request
	req := &Int32QueryRequest{}
	ok, err := gonic.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	queries := r.URL.Query()
	var queryErr error
	req.Int32, queryErr = gonic.DecodeForm[int32](queryErr, queries, "int32", gonic.GetInt32)
	req.Sint32, queryErr = gonic.DecodeForm[int32](queryErr, queries, "sint32", gonic.GetInt32)
	req.Sfixed32, queryErr = gonic.DecodeForm[int32](queryErr, queries, "sfixed32", gonic.GetInt32)
	req.OptInt32, queryErr = gonic.DecodeForm[*int32](queryErr, queries, "opt_int32", gonic.GetInt32Ptr)
	req.OptSint32, queryErr = gonic.DecodeForm[*int32](queryErr, queries, "opt_sint32", gonic.GetInt32Ptr)
	req.OptSfixed32, queryErr = gonic.DecodeForm[*int32](queryErr, queries, "opt_sfixed32", gonic.GetInt32Ptr)
	req.WrapInt32, queryErr = gonic.DecodeForm[*wrapperspb.Int32Value](queryErr, queries, "wrap_int32", gonic.GetInt32Value)
	req.ListInt32, queryErr = gonic.DecodeForm[[]int32](queryErr, queries, "list_int32", gonic.GetInt32Slice)
	req.ListSint32, queryErr = gonic.DecodeForm[[]int32](queryErr, queries, "list_sint32", gonic.GetInt32Slice)
	req.ListSfixed32, queryErr = gonic.DecodeForm[[]int32](queryErr, queries, "list_sfixed32", gonic.GetInt32Slice)
	req.ListWrapInt32, queryErr = gonic.DecodeForm[[]*wrapperspb.Int32Value](queryErr, queries, "list_wrap_int32", gonic.GetInt32ValueSlice)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type int32QueryGonicResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gonic.ResponseTransformer
}

func (encoder int32QueryGonicResponseEncoder) Int32Query(ctx *gin.Context, resp *httpbody.HttpBody) error {
	return gonic.EncodeHttpBody(ctx, ctx.Writer, resp)
}

type Int64QueryGonicService interface {
	Int64Query(ctx context.Context, request *Int64QueryRequest) (*httpbody.HttpBody, error)
}

func AppendInt64QueryGonicRoute[Router gin.IRoutes](router Router, service Int64QueryGonicService, opts ...gonic.Option) Router {
	options := gonic.NewOptions(opts...)
	handler := int64QueryGonicHandler{
		service: service,
		decoder: int64QueryGonicRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: int64QueryGonicResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            gonic.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Match([]string{"GET"}, "/v1/int64", gonic.Chain(handler.Int64Query(), options.Middlewares()...)...)
	return router
}

type int64QueryGonicHandler struct {
	service                 Int64QueryGonicService
	decoder                 int64QueryGonicRequestDecoder
	encoder                 int64QueryGonicResponseEncoder
	errorEncoder            gonic.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback gonic.OnValidationErrCallback
}

func (h int64QueryGonicHandler) Int64Query() gin.HandlerFunc {
	return gin.HandlerFunc(func(ctx *gin.Context) {
		in, err := h.decoder.Int64Query(ctx)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := gonic.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		out, err := h.service.Int64Query(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := h.encoder.Int64Query(ctx, out); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
	})
}

type int64QueryGonicRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder int64QueryGonicRequestDecoder) Int64Query(ctx *gin.Context) (*Int64QueryRequest, error) {
	r := ctx.Request
	req := &Int64QueryRequest{}
	ok, err := gonic.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	queries := r.URL.Query()
	var queryErr error
	req.Int64, queryErr = gonic.DecodeForm[int64](queryErr, queries, "int64", gonic.GetInt64)
	req.Sint64, queryErr = gonic.DecodeForm[int64](queryErr, queries, "sint64", gonic.GetInt64)
	req.Sfixed64, queryErr = gonic.DecodeForm[int64](queryErr, queries, "sfixed64", gonic.GetInt64)
	req.OptInt64, queryErr = gonic.DecodeForm[*int64](queryErr, queries, "opt_int64", gonic.GetInt64Ptr)
	req.OptSint64, queryErr = gonic.DecodeForm[*int64](queryErr, queries, "opt_sint64", gonic.GetInt64Ptr)
	req.OptSfixed64, queryErr = gonic.DecodeForm[*int64](queryErr, queries, "opt_sfixed64", gonic.GetInt64Ptr)
	req.WrapInt64, queryErr = gonic.DecodeForm[*wrapperspb.Int64Value](queryErr, queries, "wrap_int64", gonic.GetInt64Value)
	req.ListInt64, queryErr = gonic.DecodeForm[[]int64](queryErr, queries, "list_int64", gonic.GetInt64Slice)
	req.ListSint64, queryErr = gonic.DecodeForm[[]int64](queryErr, queries, "list_sint64", gonic.GetInt64Slice)
	req.ListSfixed64, queryErr = gonic.DecodeForm[[]int64](queryErr, queries, "list_sfixed64", gonic.GetInt64Slice)
	req.ListWrapInt64, queryErr = gonic.DecodeForm[[]*wrapperspb.Int64Value](queryErr, queries, "list_wrap_int64", gonic.GetInt64ValueSlice)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type int64QueryGonicResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gonic.ResponseTransformer
}

func (encoder int64QueryGonicResponseEncoder) Int64Query(ctx *gin.Context, resp *httpbody.HttpBody) error {
	return gonic.EncodeHttpBody(ctx, ctx.Writer, resp)
}

type Uint32QueryGonicService interface {
	Uint32Query(ctx context.Context, request *Uint32QueryRequest) (*httpbody.HttpBody, error)
}

func AppendUint32QueryGonicRoute[Router gin.IRoutes](router Router, service Uint32QueryGonicService, opts ...gonic.Option) Router {
	options := gonic.NewOptions(opts...)
	handler := uint32QueryGonicHandler{
		service: service,
		decoder: uint32QueryGonicRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: uint32QueryGonicResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            gonic.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Match([]string{"GET"}, "/v1/uint32", gonic.Chain(handler.Uint32Query(), options.Middlewares()...)...)
	return router
}

type uint32QueryGonicHandler struct {
	service                 Uint32QueryGonicService
	decoder                 uint32QueryGonicRequestDecoder
	encoder                 uint32QueryGonicResponseEncoder
	errorEncoder            gonic.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback gonic.OnValidationErrCallback
}

func (h uint32QueryGonicHandler) Uint32Query() gin.HandlerFunc {
	return gin.HandlerFunc(func(ctx *gin.Context) {
		in, err := h.decoder.Uint32Query(ctx)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := gonic.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		out, err := h.service.Uint32Query(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := h.encoder.Uint32Query(ctx, out); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
	})
}

type uint32QueryGonicRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder uint32QueryGonicRequestDecoder) Uint32Query(ctx *gin.Context) (*Uint32QueryRequest, error) {
	r := ctx.Request
	req := &Uint32QueryRequest{}
	ok, err := gonic.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	queries := r.URL.Query()
	var queryErr error
	req.Uint32, queryErr = gonic.DecodeForm[uint32](queryErr, queries, "uint32", gonic.GetUint32)
	req.Fixed32, queryErr = gonic.DecodeForm[uint32](queryErr, queries, "fixed32", gonic.GetUint32)
	req.OptUint32, queryErr = gonic.DecodeForm[*uint32](queryErr, queries, "opt_uint32", gonic.GetUint32Ptr)
	req.OptFixed32, queryErr = gonic.DecodeForm[*uint32](queryErr, queries, "opt_fixed32", gonic.GetUint32Ptr)
	req.WrapUint32, queryErr = gonic.DecodeForm[*wrapperspb.UInt32Value](queryErr, queries, "wrap_uint32", gonic.GetUint32Value)
	req.ListUint32, queryErr = gonic.DecodeForm[[]uint32](queryErr, queries, "list_uint32", gonic.GetUint32Slice)
	req.ListFixed32, queryErr = gonic.DecodeForm[[]uint32](queryErr, queries, "list_fixed32", gonic.GetUint32Slice)
	req.ListWrapUint32, queryErr = gonic.DecodeForm[[]*wrapperspb.UInt32Value](queryErr, queries, "list_wrap_uint32", gonic.GetUint32ValueSlice)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type uint32QueryGonicResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gonic.ResponseTransformer
}

func (encoder uint32QueryGonicResponseEncoder) Uint32Query(ctx *gin.Context, resp *httpbody.HttpBody) error {
	return gonic.EncodeHttpBody(ctx, ctx.Writer, resp)
}

type Uint64QueryGonicService interface {
	Uint64Query(ctx context.Context, request *Uint64QueryRequest) (*httpbody.HttpBody, error)
}

func AppendUint64QueryGonicRoute[Router gin.IRoutes](router Router, service Uint64QueryGonicService, opts ...gonic.Option) Router {
	options := gonic.NewOptions(opts...)
	handler := uint64QueryGonicHandler{
		service: service,
		decoder: uint64QueryGonicRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: uint64QueryGonicResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            gonic.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Match([]string{"GET"}, "/v1/uint64", gonic.Chain(handler.Uint64Query(), options.Middlewares()...)...)
	return router
}

type uint64QueryGonicHandler struct {
	service                 Uint64QueryGonicService
	decoder                 uint64QueryGonicRequestDecoder
	encoder                 uint64QueryGonicResponseEncoder
	errorEncoder            gonic.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback gonic.OnValidationErrCallback
}

func (h uint64QueryGonicHandler) Uint64Query() gin.HandlerFunc {
	return gin.HandlerFunc(func(ctx *gin.Context) {
		in, err := h.decoder.Uint64Query(ctx)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := gonic.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		out, err := h.service.Uint64Query(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := h.encoder.Uint64Query(ctx, out); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
	})
}

type uint64QueryGonicRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder uint64QueryGonicRequestDecoder) Uint64Query(ctx *gin.Context) (*Uint64QueryRequest, error) {
	r := ctx.Request
	req := &Uint64QueryRequest{}
	ok, err := gonic.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	queries := r.URL.Query()
	var queryErr error
	req.Uint64, queryErr = gonic.DecodeForm[uint64](queryErr, queries, "uint64", gonic.GetUint64)
	req.Fixed64, queryErr = gonic.DecodeForm[uint64](queryErr, queries, "fixed64", gonic.GetUint64)
	req.OptUint64, queryErr = gonic.DecodeForm[*uint64](queryErr, queries, "opt_uint64", gonic.GetUint64Ptr)
	req.OptFixed64, queryErr = gonic.DecodeForm[*uint64](queryErr, queries, "opt_fixed64", gonic.GetUint64Ptr)
	req.WrapUint64, queryErr = gonic.DecodeForm[*wrapperspb.UInt64Value](queryErr, queries, "wrap_uint64", gonic.GetUint64Value)
	req.ListUint64, queryErr = gonic.DecodeForm[[]uint64](queryErr, queries, "list_uint64", gonic.GetUint64Slice)
	req.ListFixed64, queryErr = gonic.DecodeForm[[]uint64](queryErr, queries, "list_fixed64", gonic.GetUint64Slice)
	req.ListWrapUint64, queryErr = gonic.DecodeForm[[]*wrapperspb.UInt64Value](queryErr, queries, "list_wrap_uint64", gonic.GetUint64ValueSlice)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type uint64QueryGonicResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gonic.ResponseTransformer
}

func (encoder uint64QueryGonicResponseEncoder) Uint64Query(ctx *gin.Context, resp *httpbody.HttpBody) error {
	return gonic.EncodeHttpBody(ctx, ctx.Writer, resp)
}

type FloatQueryGonicService interface {
	FloatQuery(ctx context.Context, request *FloatQueryRequest) (*httpbody.HttpBody, error)
}

func AppendFloatQueryGonicRoute[Router gin.IRoutes](router Router, service FloatQueryGonicService, opts ...gonic.Option) Router {
	options := gonic.NewOptions(opts...)
	handler := floatQueryGonicHandler{
		service: service,
		decoder: floatQueryGonicRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: floatQueryGonicResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            gonic.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Match([]string{"GET"}, "/v1/float", gonic.Chain(handler.FloatQuery(), options.Middlewares()...)...)
	return router
}

type floatQueryGonicHandler struct {
	service                 FloatQueryGonicService
	decoder                 floatQueryGonicRequestDecoder
	encoder                 floatQueryGonicResponseEncoder
	errorEncoder            gonic.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback gonic.OnValidationErrCallback
}

func (h floatQueryGonicHandler) FloatQuery() gin.HandlerFunc {
	return gin.HandlerFunc(func(ctx *gin.Context) {
		in, err := h.decoder.FloatQuery(ctx)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := gonic.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		out, err := h.service.FloatQuery(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := h.encoder.FloatQuery(ctx, out); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
	})
}

type floatQueryGonicRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder floatQueryGonicRequestDecoder) FloatQuery(ctx *gin.Context) (*FloatQueryRequest, error) {
	r := ctx.Request
	req := &FloatQueryRequest{}
	ok, err := gonic.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	queries := r.URL.Query()
	var queryErr error
	req.Float, queryErr = gonic.DecodeForm[float32](queryErr, queries, "float", gonic.GetFloat32)
	req.OptFloat, queryErr = gonic.DecodeForm[*float32](queryErr, queries, "opt_float", gonic.GetFloat32Ptr)
	req.WrapFloat, queryErr = gonic.DecodeForm[*wrapperspb.FloatValue](queryErr, queries, "wrap_float", gonic.GetFloat32Value)
	req.ListFloat, queryErr = gonic.DecodeForm[[]float32](queryErr, queries, "list_float", gonic.GetFloat32Slice)
	req.ListWrapFloat, queryErr = gonic.DecodeForm[[]*wrapperspb.FloatValue](queryErr, queries, "list_wrap_float", gonic.GetFloat32ValueSlice)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type floatQueryGonicResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gonic.ResponseTransformer
}

func (encoder floatQueryGonicResponseEncoder) FloatQuery(ctx *gin.Context, resp *httpbody.HttpBody) error {
	return gonic.EncodeHttpBody(ctx, ctx.Writer, resp)
}

type DoubleQueryGonicService interface {
	DoubleQuery(ctx context.Context, request *DoubleQueryRequest) (*httpbody.HttpBody, error)
}

func AppendDoubleQueryGonicRoute[Router gin.IRoutes](router Router, service DoubleQueryGonicService, opts ...gonic.Option) Router {
	options := gonic.NewOptions(opts...)
	handler := doubleQueryGonicHandler{
		service: service,
		decoder: doubleQueryGonicRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: doubleQueryGonicResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            gonic.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Match([]string{"GET"}, "/v1/double", gonic.Chain(handler.DoubleQuery(), options.Middlewares()...)...)
	return router
}

type doubleQueryGonicHandler struct {
	service                 DoubleQueryGonicService
	decoder                 doubleQueryGonicRequestDecoder
	encoder                 doubleQueryGonicResponseEncoder
	errorEncoder            gonic.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback gonic.OnValidationErrCallback
}

func (h doubleQueryGonicHandler) DoubleQuery() gin.HandlerFunc {
	return gin.HandlerFunc(func(ctx *gin.Context) {
		in, err := h.decoder.DoubleQuery(ctx)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := gonic.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		out, err := h.service.DoubleQuery(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := h.encoder.DoubleQuery(ctx, out); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
	})
}

type doubleQueryGonicRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder doubleQueryGonicRequestDecoder) DoubleQuery(ctx *gin.Context) (*DoubleQueryRequest, error) {
	r := ctx.Request
	req := &DoubleQueryRequest{}
	ok, err := gonic.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	queries := r.URL.Query()
	var queryErr error
	req.Double, queryErr = gonic.DecodeForm[float64](queryErr, queries, "double", gonic.GetFloat64)
	req.OptDouble, queryErr = gonic.DecodeForm[*float64](queryErr, queries, "opt_double", gonic.GetFloat64Ptr)
	req.WrapDouble, queryErr = gonic.DecodeForm[*wrapperspb.DoubleValue](queryErr, queries, "wrap_double", gonic.GetFloat64Value)
	req.ListDouble, queryErr = gonic.DecodeForm[[]float64](queryErr, queries, "list_double", gonic.GetFloat64Slice)
	req.ListWrapDouble, queryErr = gonic.DecodeForm[[]*wrapperspb.DoubleValue](queryErr, queries, "list_wrap_double", gonic.GetFloat64ValueSlice)
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type doubleQueryGonicResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gonic.ResponseTransformer
}

func (encoder doubleQueryGonicResponseEncoder) DoubleQuery(ctx *gin.Context, resp *httpbody.HttpBody) error {
	return gonic.EncodeHttpBody(ctx, ctx.Writer, resp)
}

type StringQueryGonicService interface {
	StringQuery(ctx context.Context, request *StringQueryRequest) (*httpbody.HttpBody, error)
}

func AppendStringQueryGonicRoute[Router gin.IRoutes](router Router, service StringQueryGonicService, opts ...gonic.Option) Router {
	options := gonic.NewOptions(opts...)
	handler := stringQueryGonicHandler{
		service: service,
		decoder: stringQueryGonicRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: stringQueryGonicResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            gonic.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Match([]string{"GET"}, "/v1/string", gonic.Chain(handler.StringQuery(), options.Middlewares()...)...)
	return router
}

type stringQueryGonicHandler struct {
	service                 StringQueryGonicService
	decoder                 stringQueryGonicRequestDecoder
	encoder                 stringQueryGonicResponseEncoder
	errorEncoder            gonic.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback gonic.OnValidationErrCallback
}

func (h stringQueryGonicHandler) StringQuery() gin.HandlerFunc {
	return gin.HandlerFunc(func(ctx *gin.Context) {
		in, err := h.decoder.StringQuery(ctx)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := gonic.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		out, err := h.service.StringQuery(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := h.encoder.StringQuery(ctx, out); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
	})
}

type stringQueryGonicRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder stringQueryGonicRequestDecoder) StringQuery(ctx *gin.Context) (*StringQueryRequest, error) {
	r := ctx.Request
	req := &StringQueryRequest{}
	ok, err := gonic.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	queries := r.URL.Query()
	var queryErr error
	req.String_ = queries.Get("string")
	req.OptString = proto.String(queries.Get("opt_string"))
	req.WrapString = wrapperspb.String(queries.Get("wrap_string"))
	req.ListString = queries["list_string"]
	req.ListWrapString = gonic.WrapStringSlice(queries["list_wrap_string"])
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type stringQueryGonicResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gonic.ResponseTransformer
}

func (encoder stringQueryGonicResponseEncoder) StringQuery(ctx *gin.Context, resp *httpbody.HttpBody) error {
	return gonic.EncodeHttpBody(ctx, ctx.Writer, resp)
}

type EnumQueryGonicService interface {
	EnumQuery(ctx context.Context, request *EnumQueryRequest) (*httpbody.HttpBody, error)
}

func AppendEnumQueryGonicRoute[Router gin.IRoutes](router Router, service EnumQueryGonicService, opts ...gonic.Option) Router {
	options := gonic.NewOptions(opts...)
	handler := enumQueryGonicHandler{
		service: service,
		decoder: enumQueryGonicRequestDecoder{
			unmarshalOptions: options.UnmarshalOptions(),
		},
		encoder: enumQueryGonicResponseEncoder{
			marshalOptions:      options.MarshalOptions(),
			unmarshalOptions:    options.UnmarshalOptions(),
			responseTransformer: options.ResponseTransformer(),
		},
		errorEncoder:            gonic.DefaultEncodeError,
		shouldFailFast:          options.ShouldFailFast(),
		onValidationErrCallback: options.OnValidationErrCallback(),
	}
	router.Match([]string{"GET"}, "/v1/enum", gonic.Chain(handler.EnumQuery(), options.Middlewares()...)...)
	return router
}

type enumQueryGonicHandler struct {
	service                 EnumQueryGonicService
	decoder                 enumQueryGonicRequestDecoder
	encoder                 enumQueryGonicResponseEncoder
	errorEncoder            gonic.ErrorEncoder
	shouldFailFast          bool
	onValidationErrCallback gonic.OnValidationErrCallback
}

func (h enumQueryGonicHandler) EnumQuery() gin.HandlerFunc {
	return gin.HandlerFunc(func(ctx *gin.Context) {
		in, err := h.decoder.EnumQuery(ctx)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := gonic.ValidateRequest(ctx, in, h.shouldFailFast, h.onValidationErrCallback); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		out, err := h.service.EnumQuery(ctx, in)
		if err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
		if err := h.encoder.EnumQuery(ctx, out); err != nil {
			h.errorEncoder(ctx, err, ctx.Writer)
			return
		}
	})
}

type enumQueryGonicRequestDecoder struct {
	unmarshalOptions protojson.UnmarshalOptions
}

func (decoder enumQueryGonicRequestDecoder) EnumQuery(ctx *gin.Context) (*EnumQueryRequest, error) {
	r := ctx.Request
	req := &EnumQueryRequest{}
	ok, err := gonic.CustomDecodeRequest(ctx, r, req)
	if err != nil {
		return nil, err
	}
	if ok {
		return req, nil
	}
	queries := r.URL.Query()
	var queryErr error
	req.Status, queryErr = gonic.DecodeForm[EnumQueryRequest_Status](queryErr, queries, "status", gonic.GetInt[EnumQueryRequest_Status])
	req.OptStatus, queryErr = gonic.DecodeForm[*EnumQueryRequest_Status](queryErr, queries, "opt_status", gonic.GetIntPtr[EnumQueryRequest_Status])
	req.ListStatus, queryErr = gonic.DecodeForm[[]EnumQueryRequest_Status](queryErr, queries, "list_status", gonic.GetIntSlice[EnumQueryRequest_Status])
	if queryErr != nil {
		return nil, queryErr
	}
	return req, nil
}

type enumQueryGonicResponseEncoder struct {
	marshalOptions      protojson.MarshalOptions
	unmarshalOptions    protojson.UnmarshalOptions
	responseTransformer gonic.ResponseTransformer
}

func (encoder enumQueryGonicResponseEncoder) EnumQuery(ctx *gin.Context, resp *httpbody.HttpBody) error {
	return gonic.EncodeHttpBody(ctx, ctx.Writer, resp)
}

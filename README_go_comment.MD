- [gors](#gors)
- [快速开始](#快速开始)
	- [1. 安装](#1-安装)
	- [2. 定义Restful服务](#2-定义restful服务)
	- [3. 生成gin路由代码](#3-生成gin路由代码)
	- [4. 实现服务](#4-实现服务)
	- [5. 启动服务](#5-启动服务)
	- [注意](#注意)
- [注解大全](#注解大全)
	- [@GORS](#gors-1)
	- [@Path](#path)
	- [HTTP Method注解](#http-method注解)
		- [@GET](#get)
		- [@HEAD](#head)
		- [@POST](#post)
		- [@PUT](#put)
		- [@PATCH](#patch)
		- [@DELETE](#delete)
		- [@CONNECT](#connect)
		- [@OPTIONS](#options)
		- [@TRACE](#trace)
	- [Binding 注解](#binding-注解)
		- [@UriBinding](#uribinding)
		- [@QueryBinding](#querybinding)
		- [@HeaderBinding](#headerbinding)
		- [@JSONBinding](#jsonbinding)
		- [@FormBinding](#formbinding)
		- [@FormPostBinding](#formpostbinding)
		- [@FormMultipartBinding](#formmultipartbinding)
		- [@ProtoBufBinding](#protobufbinding)
		- [@ProtoJSONBinding](#protojsonbinding)
		- [@MsgPackBinding](#msgpackbinding)
		- [@XMLBinding](#xmlbinding)
		- [@YAMLBinding](#yamlbinding)
		- [@TOMLBinding](#tomlbinding)
		- [@CustomBinding](#custombinding)
	- [Render 注解](#render-注解)
		- [@BytesRender](#bytesrender)
		- [@StringRender](#stringrender)
		- [@TextRender](#textrender)
		- [@HTMLRender](#htmlrender)
		- [@RedirectRender](#redirectrender)
		- [@ReaderRender](#readerrender)
		- [@JSONRender](#jsonrender)
		- [@IndentedJSONRender](#indentedjsonrender)
		- [@SecureJSONRender](#securejsonrender)
		- [@JsonpJSONRender](#jsonpjsonrender)
		- [@PureJSONRender](#purejsonrender)
		- [@AsciiJSONRender](#asciijsonrender)
		- [@ProtoJSONRender](#protojsonrender)
		- [@XMLRender](#xmlrender)
		- [@YAMLRender](#yamlrender)
		- [@ProtoBufRender](#protobufrender)
		- [@MsgPackRender](#msgpackrender)
		- [@TOMLRender](#tomlrender)
		- [@CustomRender](#customrender)
- [Validate](#validate)
	- [Validator接口](#validator接口)
# gors

GORS（Go Restful service）通过 Go 原生 interface 生成 Restful 服务。
在 Interface 标注特殊的注解，可以生成Gin路由。

# 快速开始
## 1. 安装
```
go install github.com/go-leo/gors/cmd/gors@latest
```

## 2. 定义Restful服务

通过Interface定义接口:
```go
//go:generate gors -service Service

// Service
// @GORS @Path("/api)  @Path("/v1)
type Service interface {
	// Method
    // @GORS @GET @Path("/method/:id) @UriBinding @JSONRender
    Method(context.Context, *MethodReq) (*MethodResp, error)
}
type MethodReq struct {
	ID int `uri:"id"`
}
type MethodResp struct {
	V int `json:"v,omitempty"`
}
```

## 3. 生成gin路由代码
运行`go generate ./...`命令，生产文件service_gors.go

```go
// Code generated by "gors -service Service"; DO NOT EDIT.

package demo

import (
	gin "github.com/gin-gonic/gin"
	gors "github.com/go-leo/gors"
	http "net/http"
)

func ServiceRoutes(srv Service, opts ...gors.Option) []gors.Route {
	options := gors.New(opts...)
	_ = options
	return []gors.Route{
		gors.NewRoute(
			http.MethodGet,
			"/api/v1/method/:id",
			func(c *gin.Context) {
				var rpcMethodName = "/demo.Service/Method"
				var ctx = gors.NewContext(c, rpcMethodName)
				var req *MethodReq
				var resp *MethodResp
				var err error
				req = new(MethodReq)
				if err = gors.RequestBind(
					ctx, req, options.Tag,
					gors.UriBinding,
				); err != nil {
					gors.ErrorRender(ctx, err, options.ErrorHandler, options.ResponseWrapper)
					return
				}
				resp, err = srv.Method(ctx, req)
				if err != nil {
					gors.ErrorRender(ctx, err, options.ErrorHandler, options.ResponseWrapper)
					return
				}
				gors.ResponseRender(ctx, gors.StatusCode(ctx), resp, "", gors.JSONRender, options.ResponseWrapper)
			},
		),
	}
}
```

## 4. 实现接口
```go
var _ demo.Service = new(Service)

type Service struct {}

func (svc *Service) Method(ctx context.Context, req *demo.MethodReq) (*demo.MethodResp, error) {
	fmt.Println(req.ID)
	return &demo.MethodResp{V: 10}, nil
}
```

## 5. 启动服务
```go
package main

import (
	"net"
	"net/http"

	"github.com/gin-gonic/gin"

	"github.com/go-leo/gors"
	"github.com/go-leo/gors/example/api/demo"
	"github.com/go-leo/gors/example/internal/app/api/svc"
)

func main() {
	engine := gin.New()
	engine = gors.AppendRoutes(engine, demo.ServiceRoutes(new(svc.Service))...)
	srv := http.Server{Handler: engine}
	listen, err := net.Listen("tcp", ":8088")
	if err != nil {
		panic(err)
	}
	err = srv.Serve(listen)
	if err != nil {
		panic(err)
	}
}
```

## 注意
通过Interface定义接口, 请求和响应参数需要满足一下：
* 请求参数一：第一个参数必须是`context.Context`,其他类型都会生成失败。
* 请求参数二： 第二个参数有四种类型：`io.Reader`、`[]byte`、`string`和`结构体指针`,其他类型都会生成失败。
    - `io.Reader`，直接取`http.Request`里的`Body`。只能支持`@ReaderBinding`。
    - `[]byte`，将`http.Request`里的`Body`以字节数组形式全部读出。只能支持`@BytesBinding`。
    - `string`，将`http.Request`里的`Body`以字符串形式全部读出。只能支持`@StringBinding`。
    - `结构体指针`，支持除以上三种以外的所有Binding，将path、query、header和body中的参数，绑定到内部字段里。
* 响应参数一：第一个响应参数有四种类型：`string`、`[]byte`、`io.Reader`和`结构体指针`,其他类型都会生成失败。
    - `io.Reader`，将`io.Reader`写入响应的Body中，必须要配合`@ReaderRender`注解使用，可以自定义响应`Content-Type`，比如`@ReaderRender(video/mpeg4)`
    - `[]byte`，将`[]byte`写入响应的Body中，必须要配合`@BytesRender`注解使用，可以自定义响应`Content-Type`，比如`@BytesRender(image/png)`
    - `string`,可以配合不同的Render策略进行响应。
      * `@TextRender`, 将文本以`Content-Type`为`"text/plain; charset=utf-8"`写入响应的Body中。
      * `@HTMLRender`, 将文本以`Content-Type`为`"text/html; charset=utf-8"`写入响应的Body中。
      * `@StringRender`, 将文本写入响应的Body中，可以自定义响应`Content-Type`，比如`@StringRender(text/xml)`
      * `@RedirectRender`, 重定向渲染，重定向到文本指定的位置。
    - `结构体指针`，需要配合各自Render策略，将结构体指针序列化成`[]byte`后,写入响应的Body中。
* 响应参数二：第一个请求参数必须是`error`,其他类型都会生成失败。

# 注解大全
[注解大全](README_comments.MD)

# 例子
[demo](example%2Fapi%2Fdemo)
package generator

import (
	"github.com/go-leo/gors/cmd/protoc-gen-gors/protoc-gen-openapi/generator"
	"github.com/go-leo/gors/internal/pkg/parser"
	"github.com/google/gnostic-models/openapiv3"
	openapiv3 "github.com/google/gnostic/openapiv3"
	"google.golang.org/protobuf/types/descriptorpb"
	"strconv"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

const deprecationComment = "// Deprecated: Do not use."

const version = "1.3.0"

const (
	// FileDescriptorProto.package field number
	fileDescriptorProtoPackageFieldNumber = 2

	// FileDescriptorProto.syntax field number
	fileDescriptorProtoSyntaxFieldNumber = 12
)

const (
	contextPackage   = protogen.GoImportPath("context")
	grpcPackage      = protogen.GoImportPath("google.golang.org/grpc")
	gorsPackage      = protogen.GoImportPath("github.com/go-leo/gors")
	metadataPackage  = protogen.GoImportPath("google.golang.org/grpc/metadata")
	ginPackage       = protogen.GoImportPath("github.com/gin-gonic/gin")
	codesPackage     = protogen.GoImportPath("google.golang.org/grpc/codes")
	statusPackage    = protogen.GoImportPath("google.golang.org/grpc/status")
	httpPackage      = protogen.GoImportPath("net/http")
	openapiv3Package = protogen.GoImportPath("github.com/google/gnostic/openapiv3")
	bindingPackage   = protogen.GoImportPath("github.com/go-leo/gors/pkg/binding")
)

// Generator holds internal state needed to generate an OpenAPIv3 document for a transcoded Protocol Buffer service.
type Generator struct {
	plugin             *protogen.Plugin
	inputFile          *protogen.File
	outputFile         *protogen.GeneratedFile
	openAPIv3Generator *generator.OpenAPIv3Generator
}

func (g *Generator) OutputFile() *protogen.GeneratedFile {
	return g.outputFile
}

// NewGenerator creates a new generator for a protoc plugin invocation.
func NewGenerator(
	plugin *protogen.Plugin,
	inputFile *protogen.File,
	outputFile *protogen.GeneratedFile,
	openAPIv3Generator *generator.OpenAPIv3Generator,
) *Generator {
	return &Generator{
		plugin:             plugin,
		inputFile:          inputFile,
		outputFile:         outputFile,
		openAPIv3Generator: openAPIv3Generator,
	}
}

// Run runs the generator.
func (g *Generator) Run() error {
	g.printHeader()

	g.printServiceRoutesFunctions()

	if *GrpcServer {
		g.printGRPCServerRoutesFunctions()
	}
	if *GrpcClient {
		g.printGRPCClientRoutesFunctions()
	}

	g.printServices()

	g.printServiceWrappers()

	if *GrpcServer {
		g.printGRPCServerWrappers()
	}
	if *GrpcClient {
		g.printGRPCClientWrappers()
	}

	g.printHandlers()

	g.printParameters()

	return nil
}

func (g *Generator) printHeader() {
	// Attach all comments associated with the syntax field.
	g.genLeadingComments(g.inputFile.Desc.SourceLocations().ByPath(protoreflect.SourcePath{fileDescriptorProtoSyntaxFieldNumber}))
	g.outputFile.P("// Code generated by protoc-gen-gors. DO NOT EDIT.")
	g.outputFile.P("// versions:")
	g.outputFile.P("// - protoc-gen-gors v", version)
	g.outputFile.P("// - protoc             ", protocVersion(g.plugin))
	if g.inputFile.Proto.GetOptions().GetDeprecated() {
		g.outputFile.P("// ", g.inputFile.Desc.Path(), " is a deprecated file.")
	} else {
		g.outputFile.P("// source: ", g.inputFile.Desc.Path())
	}
	g.outputFile.P()
	// Attach all comments associated with the package field.
	g.genLeadingComments(g.inputFile.Desc.SourceLocations().ByPath(protoreflect.SourcePath{fileDescriptorProtoPackageFieldNumber}))
	g.outputFile.P("package ", g.inputFile.GoPackageName)
	g.outputFile.P()
}

func (g *Generator) genLeadingComments(loc protoreflect.SourceLocation) {
	for _, s := range loc.LeadingDetachedComments {
		g.outputFile.P(protogen.Comments(s))
		g.outputFile.P()
	}
	if s := loc.LeadingComments; s != "" {
		g.outputFile.P(protogen.Comments(s))
		g.outputFile.P()
	}
}

func (g *Generator) printServices() {
	for _, service := range g.inputFile.Services {
		// Service interface.
		g.printService(service)
	}
}

func (g *Generator) printService(service *protogen.Service) {
	serviceName := serviceName(service)
	g.outputFile.P("// ", serviceName, " is the service API for ", service.GoName, " service.")
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.outputFile.P("//")
		g.outputFile.P(deprecationComment)
	}
	g.outputFile.AnnotateSymbol(serviceName, protogen.Annotation{Location: service.Location})
	g.outputFile.P("type ", serviceName, " interface {")
	for _, method := range service.Methods {
		if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
			continue
		}
		g.outputFile.AnnotateSymbol(serviceName+"."+method.GoName, protogen.Annotation{Location: method.Location})
		if method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
			g.outputFile.P(deprecationComment)
		}
		g.outputFile.P(method.Comments.Leading, g.serverSignature(method))
	}
	g.outputFile.P("}")
	g.outputFile.P()
}

func (g *Generator) serverSignature(method *protogen.Method) string {
	var reqArgs []string
	ret := "error"
	// Unary RPC method
	reqArgs = append(reqArgs, g.outputFile.QualifiedGoIdent(contextPackage.Ident("Context")))
	reqArgs = append(reqArgs, "*"+g.outputFile.QualifiedGoIdent(method.Input.GoIdent))
	ret = "(*" + g.outputFile.QualifiedGoIdent(method.Output.GoIdent) + ", error)"
	return method.GoName + "(" + strings.Join(reqArgs, ", ") + ") " + ret
}

func (g *Generator) printServiceRoutesFunctions() {
	for _, service := range g.inputFile.Services {
		g.printServiceRoutesFunction(service)
	}
}

func (g *Generator) printServiceRouteParameters(service *protogen.Service) {
	for _, method := range service.Methods {
		_, openapiPaths, _ := g.openAPIv3Generator.BuildPaths(g.inputFile, service, method)
		for _, namedPathItem := range openapiPaths.GetPath() {
			pathItem := namedPathItem.GetValue()
			httpMethod, _ := convertHttpMethod(pathItem)
			namedPath := convertPath(namedPathItem.GetName())
			g.outputFile.P(gorsPackage.Ident("NewRoute"), "(", strconv.Quote(httpMethod), ",", strconv.Quote(namedPath), ",", handlerName(service, method), "(wrapper, options),", "),")
		}
	}
}

func (g *Generator) printServiceRoutes(service *protogen.Service) {
	for _, method := range service.Methods {
		_, openapiPaths, _ := g.openAPIv3Generator.BuildPaths(g.inputFile, service, method)
		for _, namedPathItem := range openapiPaths.GetPath() {
			pathItem := namedPathItem.GetValue()
			httpMethod, _ := convertHttpMethod(pathItem)
			namedPath := convertPath(namedPathItem.GetName())
			g.outputFile.P(gorsPackage.Ident("NewRoute"), "(", strconv.Quote(httpMethod), ",", strconv.Quote(namedPath), ",", handlerName(service, method), "(wrapper, options,", bindingName(service, method, httpMethod, namedPath), "()),", "),")
		}
	}
}

func (g *Generator) printServiceRoutesFunction(service *protogen.Service) {
	g.outputFile.P("func ", serviceRoutesFunctionName(service), "(svc ", serviceName(service), ", opts ...", gorsPackage.Ident("Option"), ") []", gorsPackage.Ident("Route"), " {")
	g.outputFile.P("options := ", gorsPackage.Ident("NewOptions"), "(opts...)")
	g.outputFile.P("wrapper := &", serviceWrapperName(service), "{svc: svc, options: options}")
	g.outputFile.P("_ = wrapper")
	g.outputFile.P("return []", gorsPackage.Ident("Route"), "{")
	g.printServiceRoutes(service)
	g.outputFile.P("}")
	g.outputFile.P("}")
	g.outputFile.P()
}

func (g *Generator) printGRPCServerRoutesFunctions() {
	for _, service := range g.inputFile.Services {
		g.printGRPCServerRoutesFunction(service)
	}
}

func (g *Generator) printGRPCServerRoutesFunction(service *protogen.Service) {
	g.outputFile.P("func ", gRPCServerRoutesFunctionName(service), "(srv ", gRPCServerName(service), ", opts ...", gorsPackage.Ident("Option"), ") []", gorsPackage.Ident("Route"), " {")
	g.outputFile.P("options := ", gorsPackage.Ident("NewOptions"), "(opts...)")
	g.outputFile.P("wrapper := &", gRPCServerWrapperName(service), "{srv: srv, options: options}")
	g.outputFile.P("_ = wrapper")
	g.outputFile.P("return []", gorsPackage.Ident("Route"), "{")
	g.printServiceRoutes(service)
	g.outputFile.P("}")
	g.outputFile.P("}")
	g.outputFile.P()
}

func (g *Generator) printGRPCClientRoutesFunctions() {
	for _, service := range g.inputFile.Services {
		g.printGRPCClientRoutesFunction(service)
	}
}

func (g *Generator) printGRPCClientRoutesFunction(service *protogen.Service) {
	g.outputFile.P("func ", gRPCClientRoutesFunctionName(service), "(cli ", gRPCClientName(service), ", opts ...", gorsPackage.Ident("Option"), ") []", gorsPackage.Ident("Route"), " {")
	g.outputFile.P("options := ", gorsPackage.Ident("NewOptions"), "(opts...)")
	g.outputFile.P("wrapper := &", grpcClientWrapperName(service), "{cli: cli, options: options}")
	g.outputFile.P("_ = wrapper")
	g.outputFile.P("return []", gorsPackage.Ident("Route"), "{")
	g.printServiceRoutes(service)
	g.outputFile.P("}")
	g.outputFile.P("}")
	g.outputFile.P()
}

func (g *Generator) printServiceWrappers() {
	for _, service := range g.inputFile.Services {
		g.printServiceWrapper(service)
	}
}

func (g *Generator) printServiceWrapper(service *protogen.Service) {
	serviceName := serviceName(service)
	wrapperName := serviceWrapperName(service)
	g.outputFile.P("var _ ", serviceName, " = (*", wrapperName, ")(nil)")
	g.outputFile.P()
	g.outputFile.P("type ", wrapperName, " struct {")
	g.outputFile.P("svc ", serviceName)
	g.outputFile.P("options *", gorsPackage.Ident("Options"))
	g.outputFile.P("}")
	g.outputFile.P()
	for _, method := range service.Methods {
		if !method.Desc.IsStreamingServer() && !method.Desc.IsStreamingClient() {
			// Unary RPC method
			g.outputFile.P("func (wrapper *", wrapperName, ") ", method.GoName, "(ctx ", contextPackage.Ident("Context"), ", request *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error) {")
			g.outputFile.P("return wrapper.svc.", method.GoName, "(ctx, request)")
			g.outputFile.P("}")
			g.outputFile.P()
		} else {
			// Streaming RPC method
		}
	}
}

func (g *Generator) printGRPCServerWrappers() {
	for _, service := range g.inputFile.Services {
		g.printGRPCServerWrapper(service)
	}
}

func (g *Generator) printGRPCServerWrapper(service *protogen.Service) {
	serviceName := serviceName(service)
	serverName := gRPCServerName(service)
	wrapperName := gRPCServerWrapperName(service)
	g.outputFile.P("var _ ", serviceName, " = (*", wrapperName, ")(nil)")
	g.outputFile.P()
	g.outputFile.P("// ", wrapperName, " implement ", serviceName, " and wrap gRPC ", serverName)
	g.outputFile.P("type ", wrapperName, " struct {")
	g.outputFile.P("srv ", serverName)
	g.outputFile.P("options *", gorsPackage.Ident("Options"))
	g.outputFile.P("}")
	g.outputFile.P()
	for _, method := range service.Methods {
		if !method.Desc.IsStreamingServer() && !method.Desc.IsStreamingClient() {
			// Unary RPC method
			g.outputFile.P("func (wrapper *", wrapperName, ") ", method.GoName, "(ctx ", contextPackage.Ident("Context"), ", request *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error) {")
			g.outputFile.P("rpcMethodName := ", strconv.Quote(fullMethodName(service, method)))
			g.outputFile.P("stream := ", gorsPackage.Ident("NewServerTransportStream"), "(rpcMethodName)")
			g.outputFile.P("ctx = ", grpcPackage.Ident("NewContextWithServerTransportStream"), "(ctx, stream)")
			g.outputFile.P("resp, err := wrapper.srv.", method.GoName, "(ctx, request)")
			g.outputFile.P(gorsPackage.Ident("AddGRPCMetadata"), "(ctx, stream.Header(), stream.Trailer(), wrapper.options.OutgoingHeaderMatcher)")
			g.outputFile.P("return resp, err")
			g.outputFile.P("}")
			g.outputFile.P()
		} else {
			// Streaming RPC method
		}
	}
}

func (g *Generator) printGRPCClientWrappers() {
	for _, service := range g.inputFile.Services {
		g.printGRPCClientWrapper(service)
	}
}

func (g *Generator) printGRPCClientWrapper(service *protogen.Service) {
	serviceName := serviceName(service)
	clientName := gRPCClientName(service)
	wrapperName := grpcClientWrapperName(service)
	g.outputFile.P("var _ ", serviceName, " = (*", wrapperName, ")(nil)")
	g.outputFile.P()
	g.outputFile.P("// ", wrapperName, " implement ", serviceName, " and wrap gRPC ", clientName)
	g.outputFile.P("type ", wrapperName, " struct {")
	g.outputFile.P("cli ", clientName)
	g.outputFile.P("options *", gorsPackage.Ident("Options"))
	g.outputFile.P("}")
	g.outputFile.P()
	for _, method := range service.Methods {
		if !method.Desc.IsStreamingServer() && !method.Desc.IsStreamingClient() {
			// Unary RPC method
			g.outputFile.P("func (wrapper *", wrapperName, ") ", method.GoName, "(ctx ", contextPackage.Ident("Context"), ", request *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error) {")
			g.outputFile.P("var headerMD, trailerMD ", metadataPackage.Ident("MD"))
			g.outputFile.P("resp, err := wrapper.cli.", method.GoName, "(ctx, request, ", grpcPackage.Ident("Header"), "(&headerMD), ", grpcPackage.Ident("Trailer"), "(&trailerMD))")
			g.outputFile.P(gorsPackage.Ident("AddGRPCMetadata"), "(ctx, headerMD, trailerMD, wrapper.options.OutgoingHeaderMatcher)")
			g.outputFile.P("return resp, err")
			g.outputFile.P("}")
			g.outputFile.P()
		} else {
			// Streaming RPC method
		}
	}
}

func (g *Generator) printHandlers() {
	for _, service := range g.inputFile.Services {
		g.printHandler(service)
	}
}

func (g *Generator) printHandler(service *protogen.Service) {
	serviceName := serviceName(service)
	for _, method := range service.Methods {
		if method.Desc.IsStreamingServer() || method.Desc.IsStreamingClient() {
			continue
		}
		g.outputFile.P("func ", handlerName(service, method), "(svc ", serviceName, ", options *", gorsPackage.Ident("Options"), ", binding *", bindingPackage.Ident("HttpRuleBinding"), ") func(c *", ginPackage.Ident("Context"), ") {")
		g.outputFile.P("return func(c *", ginPackage.Ident("Context"), ") {")
		g.printRouteHandler(service, method)
		g.outputFile.P("}")
		g.outputFile.P("}")
		g.outputFile.P()
	}

}

func (g *Generator) printRouteHandler(service *protogen.Service, method *protogen.Method) {
	g.outputFile.P("var rpcMethodName = ", strconv.Quote(fullMethodName(service, method)))
	g.outputFile.P("var ctx = ", gorsPackage.Ident("NewContext"), "(c, rpcMethodName)")
	g.outputFile.P("var req *", method.Input.GoIdent)
	g.outputFile.P("var resp *", method.Output.GoIdent)
	g.outputFile.P("var err error")
	g.outputFile.P("req = new(", method.Input.GoIdent, ")")

	g.printRequestBinding()

	g.outputFile.P("if ctx, err = ", gorsPackage.Ident("NewGRPCContext"), "(ctx, options.IncomingHeaderMatcher, options.MetadataAnnotators); err != nil {")
	g.outputFile.P(gorsPackage.Ident("ErrorRender"), "(ctx, err, options.ErrorHandler, options.ResponseWrapper)")
	g.outputFile.P("return")
	g.outputFile.P("}")

	g.outputFile.P("resp, err = svc.", method.GoName, "(ctx, req)")
	g.outputFile.P("if err != nil {")
	g.outputFile.P(gorsPackage.Ident("ErrorRender"), "(ctx, err, options.ErrorHandler, options.ResponseWrapper)")
	g.outputFile.P("return")
	g.outputFile.P("}")

	g.printResponseRender(service, method)
}

func (g *Generator) printRequestBinding() {
	g.outputFile.P("if err = ", gorsPackage.Ident("RequestBind"), "(")
	g.outputFile.P("ctx, req, options.Tag,")
	g.outputFile.P(gorsPackage.Ident("HttpRuleBinding"), "(binding),")
	g.outputFile.P("); err != nil {")
	g.outputFile.P(gorsPackage.Ident("ErrorRender"), "(ctx, err, options.ErrorHandler, options.ResponseWrapper)")
	g.outputFile.P("return")
	g.outputFile.P("}")
}

func (g *Generator) printResponseRender(service *protogen.Service, method *protogen.Method) {
	render := parser.ProtoJSONRender
	renderName := strings.TrimPrefix(render.String(), "@")
	renderArg := "(options.ProtoJSONMarshalOptions)"
	g.outputFile.P(gorsPackage.Ident("ResponseRender"),
		"(ctx, ", gorsPackage.Ident("StatusCode"), "(ctx), resp,", strconv.Quote(""), ",", gorsPackage.Ident(renderName), renderArg, ", options.ResponseWrapper)")
}

func (g *Generator) printParameters() {
	for _, service := range g.inputFile.Services {
		g.printParameter(service)
	}
}

func (g *Generator) printParameter(service *protogen.Service) {
	for _, method := range service.Methods {
		g.printRouteParameter(service, method)
	}
}

func (g *Generator) printRouteParameter(service *protogen.Service, method *protogen.Method) {
	paths, openapiPaths, bodies := g.openAPIv3Generator.BuildPaths(g.inputFile, service, method)
	for i, namedPathItem := range openapiPaths.GetPath() {
		path := paths[i]
		body := bodies[i]
		path, simplePathParameters := g.openAPIv3Generator.FindSimplePathParameters(path, method.Input)
		path, namedPathParameters := g.openAPIv3Generator.FindNamedPathParameters(path, method.Input)
		httpMethod, operation := convertHttpMethod(namedPathItem.GetValue())
		var pathParameters []*openapiv3.Parameter
		var queryParameters []*openapiv3.Parameter
		var headerParameters []*openapiv3.Parameter
		var cookieParameters []*openapiv3.Parameter
		for _, parameter := range operation.Parameters {
			switch parameter.GetParameter().In {
			case "path":
				pathParameters = append(pathParameters, parameter.GetParameter())
			case "query":
				queryParameters = append(queryParameters, parameter.GetParameter())
			case "header":
				headerParameters = append(headerParameters, parameter.GetParameter())
			case "cookie":
				cookieParameters = append(cookieParameters, parameter.GetParameter())
			}
		}
		g.outputFile.P("func ", bindingName(service, method, httpMethod, convertPath(namedPathItem.GetName())), "() *", bindingPackage.Ident("HttpRuleBinding"), " {")
		g.outputFile.P("return &", bindingPackage.Ident("HttpRuleBinding"), "{")
		g.printPathParameters(simplePathParameters)
		g.printNamedPathParameters(namedPathParameters)
		g.printQueryParameters(queryParameters)
		g.PrintBodyParameters(body, operation.GetRequestBody())
		g.outputFile.P("}")
		g.outputFile.P("}")
	}
}

func (g *Generator) printPathParameters(parameters []*generator.PathParameters) {
	if len(parameters) <= 0 {
		return
	}
	g.outputFile.P("Path:[]*", bindingPackage.Ident("PathRule"), "{")
	for _, parameter := range parameters {
		parameterDoc := parameter.ParameterOrReference.GetParameter()
		name := strconv.Quote(parameterDoc.GetName())
		typ := strconv.Quote(parameterDoc.GetSchema().GetSchema().GetType())
		g.outputFile.P("{Name:", name, ", Type: ", typ, "},")
	}
	g.outputFile.P("},")

}

func (g *Generator) printNamedPathParameters(parameters *generator.PathParameters) {
	if parameters == nil {
		return
	}
	g.outputFile.P("NamedPath:&", bindingPackage.Ident("NamedPathRule"), "{")
	g.outputFile.P("Name:       ", strconv.Quote(parameters.Name), ",")
	g.outputFile.P("Parameters: []string{", "\""+strings.Join(parameters.Parameters, "\",\"")+"\"", "}", ",")
	g.outputFile.P("Template:   ", strconv.Quote(parameters.Template), ",")
	g.outputFile.P("},")
}

func (g *Generator) printQueryParameters(parameters []*openapiv3.Parameter) {
	if len(parameters) <= 0 {
		return
	}
	g.outputFile.P("Query:[]*", bindingPackage.Ident("QueryRule"), "{")
	for _, parameterDoc := range parameters {
		name := parameterDoc.GetName()
		schema := parameterDoc.GetSchema().GetSchema()
		typ := schema.GetType()
		var itemTyp string
		g.outputFile.P("// typ:", typ)
		if typ == "array" {
			items := schema.GetItems()
			itemTyp = items.GetSchemaOrReference()[0].GetSchema().GetType()
		}
		name = strconv.Quote(name)
		typ = strconv.Quote(typ)
		itemTyp = strconv.Quote(itemTyp)
		g.outputFile.P("{Name:", name, ", Type:", typ, ", ItemType:", itemTyp, "},")
	}
	g.outputFile.P("},")
}

func (g *Generator) PrintBodyParameters(body string, bodyDoc *openapi_v3.RequestBodyOrReference) {
	if len(body) == 0 {
		return
	}
	requestBody := bodyDoc.GetRequestBody()
	if requestBody == nil {
		return
	}
	content := requestBody.GetContent()
	if content == nil {
		return
	}
	properties := content.GetAdditionalProperties()
	if len(properties) == 0 {
		return
	}
	mediaType := properties[0]
	mediaValue := mediaType.GetValue()
	schemaOrReference := mediaValue.GetSchema()
	if schema := schemaOrReference.GetSchema(); schema != nil {
		g.outputFile.P("Body:&", bindingPackage.Ident("BodyRule"), "{")
		g.outputFile.P("Name:", strconv.Quote(body), ",")
		g.outputFile.P("Type: ", strconv.Quote(schema.GetType()), ",")
		g.outputFile.P("},")
		return
	} else if reference := schemaOrReference.GetReference(); reference != nil {
		g.outputFile.P("Body:&", bindingPackage.Ident("BodyRule"), "{")
		g.outputFile.P("Name:", strconv.Quote(body), ",")
		g.outputFile.P("Type: ", strconv.Quote("object"), ",")
		g.outputFile.P("},")
		return
	} else {
		return
	}
}

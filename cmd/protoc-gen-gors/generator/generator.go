// Copyright 2020 Google LLC. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package generator

import (
	"golang.org/x/exp/slices"
	"google.golang.org/protobuf/types/descriptorpb"
	"log"
	"net/url"
	"regexp"
	"strconv"
	"strings"

	"google.golang.org/genproto/googleapis/api/annotations"
	status_pb "google.golang.org/genproto/googleapis/rpc/status"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	any_pb "google.golang.org/protobuf/types/known/anypb"

	wk "github.com/google/gnostic/cmd/protoc-gen-openapi/generator/wellknown"
	v3 "github.com/google/gnostic/openapiv3"
)

var (
	Naming          *string
	FQSchemaNaming  *bool
	EnumType        *string
	CircularDepth   *int
	DefaultResponse *bool
)

const deprecationComment = "// Deprecated: Do not use."

const version = "1.3.0"

const (
	// FileDescriptorProto.package field number
	fileDescriptorProtoPackageFieldNumber = 2

	// FileDescriptorProto.syntax field number
	fileDescriptorProtoSyntaxFieldNumber = 12
)

const (
	contextPackage  = protogen.GoImportPath("context")
	grpcPackage     = protogen.GoImportPath("google.golang.org/grpc")
	gorsPackage     = protogen.GoImportPath("github.com/go-leo/gors")
	metadataPackage = protogen.GoImportPath("google.golang.org/grpc/metadata")
	ginPackage      = protogen.GoImportPath("github.com/gin-gonic/gin")
	codesPackage    = protogen.GoImportPath("google.golang.org/grpc/codes")
	statusPackage   = protogen.GoImportPath("google.golang.org/grpc/status")
	httpPackage     = protogen.GoImportPath("net/http")
)

// In order to dynamically add google.rpc.Status responses we need
// to know the message descriptors for google.rpc.Status as well
// as google.protobuf.Any.
var statusProtoDesc = (&status_pb.Status{}).ProtoReflect().Descriptor()

var anyProtoDesc = (&any_pb.Any{}).ProtoReflect().Descriptor()

// OpenAPIv3Generator holds internal state needed to generate an OpenAPIv3 document for a transcoded Protocol Buffer service.
type OpenAPIv3Generator struct {
	plugin *protogen.Plugin

	inputFile         *protogen.File
	outputFile        *protogen.GeneratedFile
	reflect           *OpenAPIv3Reflector
	generatedSchemas  []string // Names of schemas that have already been generated.
	linterRulePattern *regexp.Regexp
}

// NewOpenAPIv3Generator creates a new generator for a protoc plugin invocation.
func NewOpenAPIv3Generator(plugin *protogen.Plugin, inputFile *protogen.File, outputFile *protogen.GeneratedFile) *OpenAPIv3Generator {
	return &OpenAPIv3Generator{
		plugin: plugin,

		inputFile:         inputFile,
		outputFile:        outputFile,
		reflect:           NewOpenAPIv3Reflector(),
		generatedSchemas:  make([]string, 0),
		linterRulePattern: regexp.MustCompile(`\(-- .* --\)`),
	}
}

// Run runs the generator.
func (g *OpenAPIv3Generator) Run() error {
	g.printHeader()

	g.printServiceRoutesFunctions()
	g.printGRPCServerRoutesFunctions()
	g.printGRPCClientRoutesFunctions()

	g.printServices()

	g.printServiceWrappers()

	g.printGRPCServerWrappers()

	g.printGRPCClientWrappers()

	g.printHandlers()

	return nil
}

func (g *OpenAPIv3Generator) printHeader() {
	// Attach all comments associated with the syntax field.
	g.genLeadingComments(g.inputFile.Desc.SourceLocations().ByPath(protoreflect.SourcePath{fileDescriptorProtoSyntaxFieldNumber}))
	g.outputFile.P("// Code generated by protoc-gen-gors. DO NOT EDIT.")
	g.outputFile.P("// versions:")
	g.outputFile.P("// - protoc-gen-gors v", version)
	g.outputFile.P("// - protoc             ", protocVersion(g.plugin))
	if g.inputFile.Proto.GetOptions().GetDeprecated() {
		g.outputFile.P("// ", g.inputFile.Desc.Path(), " is a deprecated file.")
	} else {
		g.outputFile.P("// source: ", g.inputFile.Desc.Path())
	}
	g.outputFile.P()
	// Attach all comments associated with the package field.
	g.genLeadingComments(g.inputFile.Desc.SourceLocations().ByPath(protoreflect.SourcePath{fileDescriptorProtoPackageFieldNumber}))
	g.outputFile.P("package ", g.inputFile.GoPackageName)
	g.outputFile.P()
}

func (g *OpenAPIv3Generator) genLeadingComments(loc protoreflect.SourceLocation) {
	for _, s := range loc.LeadingDetachedComments {
		g.outputFile.P(protogen.Comments(s))
		g.outputFile.P()
	}
	if s := loc.LeadingComments; s != "" {
		g.outputFile.P(protogen.Comments(s))
		g.outputFile.P()
	}
}

func (g *OpenAPIv3Generator) printServices() {
	for _, service := range g.inputFile.Services {
		// Service interface.
		g.printService(service)
	}
}

func (g *OpenAPIv3Generator) printService(service *protogen.Service) {
	serviceName := serviceName(service)
	g.outputFile.P("// ", serviceName, " is the service API for ", service.GoName, " service.")
	if service.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.outputFile.P("//")
		g.outputFile.P(deprecationComment)
	}
	g.outputFile.AnnotateSymbol(serviceName, protogen.Annotation{Location: service.Location})
	g.outputFile.P("type ", serviceName, " interface {")
	for _, method := range service.Methods {
		g.outputFile.AnnotateSymbol(serviceName+"."+method.GoName, protogen.Annotation{Location: method.Location})
		if method.Desc.Options().(*descriptorpb.MethodOptions).GetDeprecated() {
			g.outputFile.P(deprecationComment)
		}
		g.outputFile.P(method.Comments.Leading, g.serverSignature(method))
	}
	g.outputFile.P("}")
	g.outputFile.P()
}

func (g *OpenAPIv3Generator) serverSignature(method *protogen.Method) string {
	var reqArgs []string
	ret := "error"
	if !method.Desc.IsStreamingClient() && !method.Desc.IsStreamingServer() {
		reqArgs = append(reqArgs, g.outputFile.QualifiedGoIdent(contextPackage.Ident("Context")))
		ret = "(*" + g.outputFile.QualifiedGoIdent(method.Output.GoIdent) + ", error)"
	}
	if !method.Desc.IsStreamingClient() {
		reqArgs = append(reqArgs, "*"+g.outputFile.QualifiedGoIdent(method.Input.GoIdent))
	}
	if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
		reqArgs = append(reqArgs, method.Parent.GoName+"_"+method.GoName+"Server")
	}
	return method.GoName + "(" + strings.Join(reqArgs, ", ") + ") " + ret
}

func (g *OpenAPIv3Generator) printServiceRoutesFunctions() {
	for _, service := range g.inputFile.Services {
		g.printServiceRoutesFunction(service)
	}
}

func (g *OpenAPIv3Generator) printServiceRoutesFunction(service *protogen.Service) {
	g.outputFile.P("func ", serviceRoutesFunctionName(service), "(svc ", serviceName(service), ", opts ...", gorsPackage.Ident("Option"), ") []", gorsPackage.Ident("Route"), " {")
	g.outputFile.P("options := ", gorsPackage.Ident("NewOptions"), "(opts...)")
	g.outputFile.P("wrapper := &", serviceWrapperName(service), "{svc: svc, options: options}")
	g.outputFile.P("return []", gorsPackage.Ident("Route"), "{")
	for _, method := range service.Methods {
		httpRules := getHttpRules(method)
		for _, httpRule := range httpRules {
			path, httpMethod, err := getHttpMethod(httpRule)
			if err != nil {
				g.plugin.Error(err)
				return
			}
			path, _ = findPathParameters(path, httpRule.Body, method.Input)
			if httpMethod != "*" {
				g.outputFile.P(gorsPackage.Ident("NewRoute"), "(", strconv.Quote(httpMethod), ",", strconv.Quote(path), ",", handlerName(service, method), "(wrapper, options),", "),")
				continue
			}
			for _, httpMethod := range httpMethods {
				g.outputFile.P(gorsPackage.Ident("NewRoute"), "(", strconv.Quote(httpMethod), ",", strconv.Quote(path), ",", handlerName(service, method), "(wrapper, options),", "),")
			}
		}
	}
	g.outputFile.P("}")
	g.outputFile.P("}")
	g.outputFile.P()
}

func (g *OpenAPIv3Generator) printGRPCServerRoutesFunctions() {
	for _, service := range g.inputFile.Services {
		g.printGRPCServerRoutesFunction(service)
	}
}

func (g *OpenAPIv3Generator) printGRPCServerRoutesFunction(service *protogen.Service) {
	g.outputFile.P("func ", gRPCServerRoutesFunctionName(service), "(srv ", gRPCServerName(service), ", opts ...", gorsPackage.Ident("Option"), ") []", gorsPackage.Ident("Route"), " {")
	g.outputFile.P("options := ", gorsPackage.Ident("NewOptions"), "(opts...)")
	g.outputFile.P("wrapper := &", gRPCServerWrapperName(service), "{srv: srv, options: options}")
	g.outputFile.P("return []", gorsPackage.Ident("Route"), "{")
	for _, method := range service.Methods {
		httpRules := getHttpRules(method)
		for _, httpRule := range httpRules {
			path, httpMethod, err := getHttpMethod(httpRule)
			if err != nil {
				g.plugin.Error(err)
				return
			}
			path, _ = findPathParameters(path, httpRule.Body, method.Input)
			if httpMethod != "*" {
				g.outputFile.P(gorsPackage.Ident("NewRoute"), "(", strconv.Quote(httpMethod), ",", strconv.Quote(path), ",", handlerName(service, method), "(wrapper, options),", "),")
				continue
			}
			for _, httpMethod := range httpMethods {
				g.outputFile.P(gorsPackage.Ident("NewRoute"), "(", strconv.Quote(httpMethod), ",", strconv.Quote(path), ",", handlerName(service, method), "(wrapper, options),", "),")
			}
		}
	}
	g.outputFile.P("}")
	g.outputFile.P("}")
	g.outputFile.P()
}

func (g *OpenAPIv3Generator) printGRPCClientRoutesFunctions() {
	for _, service := range g.inputFile.Services {
		g.printGRPCClientRoutesFunction(service)
	}
}

func (g *OpenAPIv3Generator) printGRPCClientRoutesFunction(service *protogen.Service) {
	g.outputFile.P("func ", gRPCClientRoutesFunctionName(service), "(cli ", gRPCClientName(service), ", opts ...", gorsPackage.Ident("Option"), ") []", gorsPackage.Ident("Route"), " {")
	g.outputFile.P("options := ", gorsPackage.Ident("NewOptions"), "(opts...)")
	g.outputFile.P("wrapper := &", grpcClientWrapperName(service), "{cli: cli, options: options}")
	g.outputFile.P("return []", gorsPackage.Ident("Route"), "{")
	for _, method := range service.Methods {
		httpRules := getHttpRules(method)
		for _, httpRule := range httpRules {
			path, httpMethod, err := getHttpMethod(httpRule)
			if err != nil {
				g.plugin.Error(err)
				return
			}
			path, _ = findPathParameters(path, httpRule.Body, method.Input)
			if httpMethod != "*" {
				g.outputFile.P(gorsPackage.Ident("NewRoute"), "(", strconv.Quote(httpMethod), ",", strconv.Quote(path), ",", handlerName(service, method), "(wrapper, options),", "),")
				continue
			}
			for _, httpMethod := range httpMethods {
				g.outputFile.P(gorsPackage.Ident("NewRoute"), "(", strconv.Quote(httpMethod), ",", strconv.Quote(path), ",", handlerName(service, method), "(wrapper, options),", "),")
			}
		}
	}
	g.outputFile.P("}")
	g.outputFile.P("}")
	g.outputFile.P()
}

func (g *OpenAPIv3Generator) printServiceWrappers() {
	for _, service := range g.inputFile.Services {
		g.printServiceWrapper(service)
	}
}

func (g *OpenAPIv3Generator) printServiceWrapper(service *protogen.Service) {
	serviceName := serviceName(service)
	wrapperName := serviceWrapperName(service)
	g.outputFile.P("var _ ", serviceName, " = (*", wrapperName, ")(nil)")
	g.outputFile.P()
	g.outputFile.P("type ", wrapperName, " struct {")
	g.outputFile.P("svc ", serviceName)
	g.outputFile.P("options *", gorsPackage.Ident("Options"))
	g.outputFile.P("}")
	g.outputFile.P()
	for _, method := range service.Methods {
		if !method.Desc.IsStreamingServer() && !method.Desc.IsStreamingClient() {
			// Unary RPC method
			g.outputFile.P("func (wrapper *", wrapperName, ") ", method.GoName, "(ctx ", contextPackage.Ident("Context"), ", request *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error) {")
			g.outputFile.P("return wrapper.svc.", method.GoName, "(ctx, request)")
			g.outputFile.P("}")
			g.outputFile.P()
		} else {
			// Streaming RPC method
			continue
		}
	}
}

func (g *OpenAPIv3Generator) printGRPCServerWrappers() {
	for _, service := range g.inputFile.Services {
		g.printGRPCServerWrapper(service)
	}
}

func (g *OpenAPIv3Generator) printGRPCServerWrapper(service *protogen.Service) {
	serviceName := serviceName(service)
	serverName := gRPCServerName(service)
	wrapperName := gRPCServerWrapperName(service)
	g.outputFile.P("var _ ", serviceName, " = (*", wrapperName, ")(nil)")
	g.outputFile.P()
	g.outputFile.P("// ", wrapperName, " implement ", serviceName, " and wrap gRPC ", serverName)
	g.outputFile.P("type ", wrapperName, " struct {")
	g.outputFile.P("srv ", serverName)
	g.outputFile.P("options *", gorsPackage.Ident("Options"))
	g.outputFile.P("}")
	g.outputFile.P()
	for _, method := range service.Methods {
		if !method.Desc.IsStreamingServer() && !method.Desc.IsStreamingClient() {
			// Unary RPC method
			g.outputFile.P("func (wrapper *", wrapperName, ") ", method.GoName, "(ctx ", contextPackage.Ident("Context"), ", request *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error) {")
			g.outputFile.P("rpcMethodName := ", strconv.Quote(fullMethodName(service, method)))
			g.outputFile.P("stream := ", gorsPackage.Ident("NewServerTransportStream"), "(rpcMethodName)")
			g.outputFile.P("ctx = ", grpcPackage.Ident("NewContextWithServerTransportStream"), "(ctx, stream)")
			g.outputFile.P("resp, err := wrapper.srv.", method.GoName, "(ctx, request)")
			g.outputFile.P(gorsPackage.Ident("AddGRPCMetadata"), "(ctx, stream.Header(), stream.Trailer(), wrapper.options.OutgoingHeaderMatcher)")
			g.outputFile.P("return resp, err")
			g.outputFile.P("}")
			g.outputFile.P()
		} else {
			// Streaming RPC method
			continue
		}
	}
}

func (g *OpenAPIv3Generator) printGRPCClientWrappers() {
	for _, service := range g.inputFile.Services {
		g.printGRPCClientWrapper(service)
	}
}

func (g *OpenAPIv3Generator) printGRPCClientWrapper(service *protogen.Service) {
	serviceName := serviceName(service)
	clientName := gRPCClientName(service)
	wrapperName := grpcClientWrapperName(service)
	g.outputFile.P("var _ ", serviceName, " = (*", wrapperName, ")(nil)")
	g.outputFile.P()
	g.outputFile.P("// ", wrapperName, " implement ", serviceName, " and wrap gRPC ", clientName)
	g.outputFile.P("type ", wrapperName, " struct {")
	g.outputFile.P("cli ", clientName)
	g.outputFile.P("options *", gorsPackage.Ident("Options"))
	g.outputFile.P("}")
	g.outputFile.P()
	for _, method := range service.Methods {
		if !method.Desc.IsStreamingServer() && !method.Desc.IsStreamingClient() {
			// Unary RPC method
			g.outputFile.P("func (wrapper *", wrapperName, ") ", method.GoName, "(ctx ", contextPackage.Ident("Context"), ", request *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error) {")
			g.outputFile.P("var headerMD, trailerMD ", metadataPackage.Ident("MD"))
			g.outputFile.P("resp, err := wrapper.cli.", method.GoName, "(ctx, request, ", grpcPackage.Ident("Header"), "(&headerMD), ", grpcPackage.Ident("Trailer"), "(&trailerMD))")
			g.outputFile.P(gorsPackage.Ident("AddGRPCMetadata"), "(ctx, headerMD, trailerMD, wrapper.options.OutgoingHeaderMatcher)")
			g.outputFile.P("return resp, err")
			g.outputFile.P("}")
			g.outputFile.P()
		} else {
			// Streaming RPC method
			continue
		}
	}
}

func (g *OpenAPIv3Generator) printHandlers() {
	for _, service := range g.inputFile.Services {
		g.printHandler(service)
	}
}

func (g *OpenAPIv3Generator) printHandler(service *protogen.Service) {
	serviceName := serviceName(service)
	for _, method := range service.Methods {
		g.outputFile.P("func ", handlerName(service, method), "(svc ", serviceName, ", options *", gorsPackage.Ident("Options"), ") func(c *", ginPackage.Ident("Context"), ") {")
		g.outputFile.P("return func(c *", ginPackage.Ident("Context"), ") {")
		g.printRouteHandler(service, method)
		g.outputFile.P("}")
		g.outputFile.P("}")
		g.outputFile.P()
	}

}

func (g *OpenAPIv3Generator) printRouteHandler(service *protogen.Service, method *protogen.Method) {
	g.outputFile.P("var rpcMethodName = ", strconv.Quote(fullMethodName(service, method)))
	g.outputFile.P("var ctx = ", gorsPackage.Ident("NewContext"), "(c, rpcMethodName)")
	g.outputFile.P("var req *", method.Input.GoIdent)
	g.outputFile.P("var resp *", method.Output.GoIdent)
	g.outputFile.P("var err error")
	g.outputFile.P("req = new(", method.Input.GoIdent, ")")

	g.printRequestBinding(service, method)

	g.outputFile.P("if ctx, err = ", gorsPackage.Ident("NewGRPCContext"), "(ctx, options.IncomingHeaderMatcher, options.MetadataAnnotators); err != nil {")
	g.outputFile.P(gorsPackage.Ident("ErrorRender"), "(ctx, err, options.ErrorHandler, options.ResponseWrapper)")
	g.outputFile.P("return")
	g.outputFile.P("}")

	g.outputFile.P("resp, err = svc.", method.GoName, "(ctx, req)")
	g.outputFile.P("if err != nil {")
	g.outputFile.P(gorsPackage.Ident("ErrorRender"), "(ctx, err, options.ErrorHandler, options.ResponseWrapper)")
	g.outputFile.P("return")
	g.outputFile.P("}")

	g.printResponseRender(service, method)
}

func (g *OpenAPIv3Generator) printRequestBinding(service *protogen.Service, method *protogen.Method) {
	g.outputFile.P("if err = ", gorsPackage.Ident("RequestBind"), "(")
	g.outputFile.P("ctx, req, options.Tag,")
	//for _, binding := range router.Bindings {
	//	g.outputFile.P(gorsPackage.Ident(strings.TrimPrefix(string(binding), "@")), ",")
	//}
	g.outputFile.P("); err != nil {")
	g.outputFile.P(gorsPackage.Ident("ErrorRender"), "(ctx, err, options.ErrorHandler, options.ResponseWrapper)")
	g.outputFile.P("return")
	g.outputFile.P("}")
}

func (g *OpenAPIv3Generator) printResponseRender(service *protogen.Service, method *protogen.Method) {
	//renders := []parser.Render{
	//	parser.JSONRender, parser.IndentedJSONRender, parser.SecureJSONRender,
	//	parser.PureJSONRender, parser.AsciiJSONRender, parser.ProtoJSONRender,
	//	parser.ProtoBufRender, parser.CustomRender, parser.XMLRender,
	//	parser.YAMLRender, parser.TOMLRender, parser.MsgPackRender,
	//}
	//
	//renderName := strings.TrimPrefix(router.Render.String(), "@")
	//renderArg := ""
	//if router.Render == parser.ProtoJSONRender {
	//	renderArg = "(options.ProtoJSONMarshalOptions)"
	//}
	//g.outputFile.P(gorsPackage.Ident("ResponseRender"),
	//	"(ctx, ", gorsPackage.Ident("StatusCode"), "(ctx), resp,",
	//	strconv.Quote(router.RenderContentType), ",", gorsPackage.Ident(renderName), renderArg,
	//	", options.ResponseWrapper)")
}

// filterCommentString removes linter rules from comments.
func (g *OpenAPIv3Generator) filterCommentString(c protogen.Comments) string {
	comment := g.linterRulePattern.ReplaceAllString(string(c), "")
	return strings.TrimSpace(comment)
}

// Note that fields which are mapped to URL query parameters must have a primitive type
// or a repeated primitive type or a non-repeated message type.
// In the case of a repeated type, the parameter can be repeated in the URL as ...?param=A&param=B.
// In the case of a message type, each field of the message is mapped to a separate parameter,
// such as ...?foo.a=A&foo.b=B&foo.c=C.
// There are exceptions:
// - for wrapper types it will use the same representation as the wrapped primitive type in JSON
// - for google.protobuf.timestamp type it will be serialized as a string
//
// maps, Struct and Empty can NOT be used
// messages can have any number of sub messages - including circular (e.g. sub.subsub.sub.subsub.id)

// buildQueryParamsV3 extracts any valid query params, including sub and recursive messages
func (g *OpenAPIv3Generator) buildQueryParamsV3(field *protogen.Field) []*v3.ParameterOrReference {
	depths := map[string]int{}
	return g._buildQueryParamsV3(field, depths)
}

// depths are used to keep track of how many times a message's fields has been seen
func (g *OpenAPIv3Generator) _buildQueryParamsV3(field *protogen.Field, depths map[string]int) []*v3.ParameterOrReference {
	parameters := []*v3.ParameterOrReference{}

	queryFieldName := formatFieldName(field.Desc)
	fieldDescription := g.filterCommentString(field.Comments.Leading)

	if field.Desc.IsMap() {
		// Map types are not allowed in query parameteres
		return parameters

	} else if field.Desc.Kind() == protoreflect.MessageKind {
		typeName := fullMessageTypeName(field.Desc.Message())

		switch typeName {
		case ".google.protobuf.Value":
			fieldSchema := g.reflect.schemaOrReferenceForField(field.Desc)
			parameters = append(parameters,
				&v3.ParameterOrReference{
					Oneof: &v3.ParameterOrReference_Parameter{
						Parameter: &v3.Parameter{
							Name:        queryFieldName,
							In:          "query",
							Description: fieldDescription,
							Required:    false,
							Schema:      fieldSchema,
						},
					},
				})
			return parameters

		case ".google.protobuf.BoolValue", ".google.protobuf.BytesValue", ".google.protobuf.Int32Value", ".google.protobuf.UInt32Value",
			".google.protobuf.StringValue", ".google.protobuf.Int64Value", ".google.protobuf.UInt64Value", ".google.protobuf.FloatValue",
			".google.protobuf.DoubleValue":
			valueField := getValueField(field.Message.Desc)
			fieldSchema := g.reflect.schemaOrReferenceForField(valueField)
			parameters = append(parameters,
				&v3.ParameterOrReference{
					Oneof: &v3.ParameterOrReference_Parameter{
						Parameter: &v3.Parameter{
							Name:        queryFieldName,
							In:          "query",
							Description: fieldDescription,
							Required:    false,
							Schema:      fieldSchema,
						},
					},
				})
			return parameters

		case ".google.protobuf.Timestamp":
			fieldSchema := g.reflect.schemaOrReferenceForMessage(field.Message.Desc)
			parameters = append(parameters,
				&v3.ParameterOrReference{
					Oneof: &v3.ParameterOrReference_Parameter{
						Parameter: &v3.Parameter{
							Name:        queryFieldName,
							In:          "query",
							Description: fieldDescription,
							Required:    false,
							Schema:      fieldSchema,
						},
					},
				})
			return parameters
		case ".google.protobuf.Duration":
			fieldSchema := g.reflect.schemaOrReferenceForMessage(field.Message.Desc)
			parameters = append(parameters,
				&v3.ParameterOrReference{
					Oneof: &v3.ParameterOrReference_Parameter{
						Parameter: &v3.Parameter{
							Name:        queryFieldName,
							In:          "query",
							Description: fieldDescription,
							Required:    false,
							Schema:      fieldSchema,
						},
					},
				})
			return parameters
		}

		if field.Desc.IsList() {
			// Only non-repeated message types are valid
			return parameters
		}

		// Represent field masks directly as strings (don't expand them).
		if typeName == ".google.protobuf.FieldMask" {
			fieldSchema := g.reflect.schemaOrReferenceForField(field.Desc)
			parameters = append(parameters,
				&v3.ParameterOrReference{
					Oneof: &v3.ParameterOrReference_Parameter{
						Parameter: &v3.Parameter{
							Name:        queryFieldName,
							In:          "query",
							Description: fieldDescription,
							Required:    false,
							Schema:      fieldSchema,
						},
					},
				})
			return parameters
		}

		// Sub messages are allowed, even circular, as long as the final type is a primitive.
		// Go through each of the sub message fields
		for _, subField := range field.Message.Fields {
			subFieldFullName := string(subField.Desc.FullName())
			seen, ok := depths[subFieldFullName]
			if !ok {
				depths[subFieldFullName] = 0
			}

			if seen < *CircularDepth {
				depths[subFieldFullName]++
				subParams := g._buildQueryParamsV3(subField, depths)
				for _, subParam := range subParams {
					if param, ok := subParam.Oneof.(*v3.ParameterOrReference_Parameter); ok {
						param.Parameter.Name = queryFieldName + "." + param.Parameter.Name
						parameters = append(parameters, subParam)
					}
				}
			}
		}

	} else if field.Desc.Kind() != protoreflect.GroupKind {
		// schemaOrReferenceForField also handles array types
		fieldSchema := g.reflect.schemaOrReferenceForField(field.Desc)

		parameters = append(parameters,
			&v3.ParameterOrReference{
				Oneof: &v3.ParameterOrReference_Parameter{
					Parameter: &v3.Parameter{
						Name:        queryFieldName,
						In:          "query",
						Description: fieldDescription,
						Required:    false,
						Schema:      fieldSchema,
					},
				},
			})
	}

	return parameters
}

// buildOperationV3 constructs an operation for a set of values.
func (g *OpenAPIv3Generator) buildOperationV3(
	d *v3.Document,
	operationID string,
	tagName string,
	description string,
	defaultHost string,
	path string,
	bodyField string,
	inputMessage *protogen.Message,
	outputMessage *protogen.Message,
) (*v3.Operation, string) {
	// coveredParameters tracks the parameters that have been used in the body or path.
	coveredParameters := make([]string, 0)
	if bodyField != "" {
		coveredParameters = append(coveredParameters, bodyField)
	}
	// Initialize the list of operation parameters.
	parameters := []*v3.ParameterOrReference{}

	// Find simple path parameters like {id}
	if allMatches := pathPattern.FindAllStringSubmatch(path, -1); allMatches != nil {
		for _, matches := range allMatches {
			// Add the value to the list of covered parameters.
			coveredParameters = append(coveredParameters, matches[1])
			pathParameter := findAndFormatFieldName(matches[1], inputMessage)
			path = strings.Replace(path, matches[1], pathParameter, 1)

			// Add the path parameters to the operation parameters.
			var fieldSchema *v3.SchemaOrReference

			var fieldDescription string
			field := findField(pathParameter, inputMessage)
			if field != nil {
				fieldSchema = g.reflect.schemaOrReferenceForField(field.Desc)
				fieldDescription = g.filterCommentString(field.Comments.Leading)
			} else {
				// If field does not exist, it is safe to set it to string, as it is ignored downstream
				fieldSchema = stringSchema()
			}

			param := &v3.ParameterOrReference{
				Oneof: &v3.ParameterOrReference_Parameter{
					Parameter: &v3.Parameter{
						Name:        pathParameter,
						In:          "path",
						Description: fieldDescription,
						Required:    true,
						Schema:      fieldSchema,
					},
				},
			}
			parameters = append(parameters, param)
		}
	}

	// Find named path parameters like {name=shelves/*}
	if matches := namedPathPattern.FindStringSubmatch(path); matches != nil {
		// Build a list of named path parameters.
		namedPathParameters := make([]string, 0)

		// Add the "name=" "name" value to the list of covered parameters.
		coveredParameters = append(coveredParameters, matches[1])
		// Convert the path from the starred form to use named path parameters.
		starredPath := matches[2]
		parts := strings.Split(starredPath, "/")
		// The starred path is assumed to be in the form "things/*/otherthings/*".
		// We want to convert it to "things/{thingsId}/otherthings/{otherthingsId}".
		for i := 0; i < len(parts)-1; i += 2 {
			section := parts[i]
			namedPathParameter := findAndFormatFieldName(section, inputMessage)
			namedPathParameter = singular(namedPathParameter)
			parts[i+1] = "{" + namedPathParameter + "}"
			namedPathParameters = append(namedPathParameters, namedPathParameter)
		}
		// Rewrite the path to use the path parameters.
		newPath := strings.Join(parts, "/")
		path = strings.Replace(path, matches[0], newPath, 1)

		// Add the named path parameters to the operation parameters.
		for _, namedPathParameter := range namedPathParameters {
			param := &v3.ParameterOrReference{
				Oneof: &v3.ParameterOrReference_Parameter{
					Parameter: &v3.Parameter{
						Name:        namedPathParameter,
						In:          "path",
						Required:    true,
						Description: "The " + namedPathParameter + " id.",
						Schema:      stringSchema(),
					},
				},
			}
			parameters = append(parameters, param)
		}
	}

	// Add any unhandled fields in the request message as query parameters.
	if bodyField != "*" && string(inputMessage.Desc.FullName()) != "google.api.HttpBody" {
		for _, field := range inputMessage.Fields {
			fieldName := string(field.Desc.Name())
			if !slices.Contains(coveredParameters, fieldName) && fieldName != bodyField {
				fieldParams := g.buildQueryParamsV3(field)
				parameters = append(parameters, fieldParams...)
			}
		}
	}

	// Create the response.
	name, content := g.reflect.responseContentForMessage(outputMessage.Desc)
	responses := &v3.Responses{
		ResponseOrReference: []*v3.NamedResponseOrReference{
			{
				Name: name,
				Value: &v3.ResponseOrReference{
					Oneof: &v3.ResponseOrReference_Response{
						Response: &v3.Response{
							Description: "OK",
							Content:     content,
						},
					},
				},
			},
		},
	}

	// Add the default reponse if needed
	if *DefaultResponse {
		anySchemaName := formatMessageName(anyProtoDesc)
		anySchema := wk.NewGoogleProtobufAnySchema(anySchemaName)
		g.addSchemaToDocumentV3(d, anySchema)

		statusSchemaName := formatMessageName(statusProtoDesc)
		statusSchema := wk.NewGoogleRpcStatusSchema(statusSchemaName, anySchemaName)
		g.addSchemaToDocumentV3(d, statusSchema)

		defaultResponse := &v3.NamedResponseOrReference{
			Name: "default",
			Value: &v3.ResponseOrReference{
				Oneof: &v3.ResponseOrReference_Response{
					Response: &v3.Response{
						Description: "Default error response",
						Content: wk.NewApplicationJsonMediaType(&v3.SchemaOrReference{
							Oneof: &v3.SchemaOrReference_Reference{
								Reference: &v3.Reference{XRef: "#/components/schemas/" + statusSchemaName}}}),
					},
				},
			},
		}

		responses.ResponseOrReference = append(responses.ResponseOrReference, defaultResponse)
	}

	// Create the operation.
	op := &v3.Operation{
		Tags:        []string{tagName},
		Description: description,
		OperationId: operationID,
		Parameters:  parameters,
		Responses:   responses,
	}

	if defaultHost != "" {
		hostURL, err := url.Parse(defaultHost)
		if err == nil {
			hostURL.Scheme = "https"
			op.Servers = append(op.Servers, &v3.Server{Url: hostURL.String()})
		}
	}

	// If a body field is specified, we need to pass a message as the request body.
	if bodyField != "" {
		var requestSchema *v3.SchemaOrReference

		if bodyField == "*" {
			// Pass the entire request message as the request body.
			requestSchema = g.reflect.schemaOrReferenceForMessage(inputMessage.Desc)

		} else {
			// If body refers to a message field, use that type.
			for _, field := range inputMessage.Fields {
				if string(field.Desc.Name()) == bodyField {
					switch field.Desc.Kind() {
					case protoreflect.StringKind:
						requestSchema = &v3.SchemaOrReference{
							Oneof: &v3.SchemaOrReference_Schema{
								Schema: &v3.Schema{
									Type: "string",
								},
							},
						}

					case protoreflect.MessageKind:
						requestSchema = g.reflect.schemaOrReferenceForMessage(field.Message.Desc)

					default:
						log.Printf("unsupported field type %+v", field.Desc)
					}
					break
				}
			}
		}

		op.RequestBody = &v3.RequestBodyOrReference{
			Oneof: &v3.RequestBodyOrReference_RequestBody{
				RequestBody: &v3.RequestBody{
					Required: true,
					Content: &v3.MediaTypes{
						AdditionalProperties: []*v3.NamedMediaType{
							{
								Name: "application/json",
								Value: &v3.MediaType{
									Schema: requestSchema,
								},
							},
						},
					},
				},
			},
		}
	}
	return op, path
}

func stringSchema() *v3.SchemaOrReference {
	return &v3.SchemaOrReference{Oneof: &v3.SchemaOrReference_Schema{Schema: &v3.Schema{Type: "string"}}}
}

// addOperationToDocumentV3 adds an operation to the specified path/method.
func (g *OpenAPIv3Generator) addOperationToDocumentV3(d *v3.Document, op *v3.Operation, path string, methodName string) {
	var selectedPathItem *v3.NamedPathItem
	for _, namedPathItem := range d.Paths.Path {
		if namedPathItem.Name == path {
			selectedPathItem = namedPathItem
			break
		}
	}
	// If we get here, we need to create a path item.
	if selectedPathItem == nil {
		selectedPathItem = &v3.NamedPathItem{Name: path, Value: &v3.PathItem{}}
		d.Paths.Path = append(d.Paths.Path, selectedPathItem)
	}
	// Set the operation on the specified method.
	switch methodName {
	case "GET":
		selectedPathItem.Value.Get = op
	case "POST":
		selectedPathItem.Value.Post = op
	case "PUT":
		selectedPathItem.Value.Put = op
	case "DELETE":
		selectedPathItem.Value.Delete = op
	case "PATCH":
		selectedPathItem.Value.Patch = op
	}
}

// addPathsToDocumentV3 adds paths from a specified file descriptor.
func (g *OpenAPIv3Generator) addPathsToDocumentV3(d *v3.Document, services []*protogen.Service) {
	for _, service := range services {
		annotationsCount := 0

		for _, method := range service.Methods {
			comment := g.filterCommentString(method.Comments.Leading)
			inputMessage := method.Input
			outputMessage := method.Output
			operationID := service.GoName + "_" + method.GoName

			rules := make([]*annotations.HttpRule, 0)

			extHTTP := proto.GetExtension(method.Desc.Options(), annotations.E_Http)
			if extHTTP != nil && extHTTP != annotations.E_Http.InterfaceOf(annotations.E_Http.Zero()) {
				annotationsCount++

				rule := extHTTP.(*annotations.HttpRule)
				rules = append(rules, rule)
				rules = append(rules, rule.AdditionalBindings...)
			}

			for _, rule := range rules {
				var path string
				var methodName string
				var body string

				body = rule.Body
				switch pattern := rule.Pattern.(type) {
				case *annotations.HttpRule_Get:
					path = pattern.Get
					methodName = "GET"
				case *annotations.HttpRule_Post:
					path = pattern.Post
					methodName = "POST"
				case *annotations.HttpRule_Put:
					path = pattern.Put
					methodName = "PUT"
				case *annotations.HttpRule_Delete:
					path = pattern.Delete
					methodName = "DELETE"
				case *annotations.HttpRule_Patch:
					path = pattern.Patch
					methodName = "PATCH"
				case *annotations.HttpRule_Custom:
					path = "custom-unsupported"
				default:
					path = "unknown-unsupported"
				}

				if methodName != "" {
					defaultHost := proto.GetExtension(service.Desc.Options(), annotations.E_DefaultHost).(string)

					op, path2 := g.buildOperationV3(
						d, operationID, service.GoName, comment, defaultHost, path, body, inputMessage, outputMessage)

					// Merge any `Operation` annotations with the current
					extOperation := proto.GetExtension(method.Desc.Options(), v3.E_Operation)
					if extOperation != nil {
						proto.Merge(op, extOperation.(*v3.Operation))
					}

					g.addOperationToDocumentV3(d, op, path2, methodName)
				}
			}
		}

		if annotationsCount > 0 {
			comment := g.filterCommentString(service.Comments.Leading)
			d.Tags = append(d.Tags, &v3.Tag{Name: service.GoName, Description: comment})
		}
	}
}

// addSchemaForMessageToDocumentV3 adds the schema to the document if required
func (g *OpenAPIv3Generator) addSchemaToDocumentV3(d *v3.Document, schema *v3.NamedSchemaOrReference) {
	if slices.Contains(g.generatedSchemas, schema.Name) {
		return
	}
	g.generatedSchemas = append(g.generatedSchemas, schema.Name)
	d.Components.Schemas.AdditionalProperties = append(d.Components.Schemas.AdditionalProperties, schema)
}

// addSchemasForMessagesToDocumentV3 adds info from one file descriptor.
func (g *OpenAPIv3Generator) addSchemasForMessagesToDocumentV3(d *v3.Document, messages []*protogen.Message) {
	// For each message, generate a definition.
	for _, message := range messages {
		if message.Messages != nil {
			g.addSchemasForMessagesToDocumentV3(d, message.Messages)
		}

		schemaName := formatMessageName(message.Desc)

		// Only generate this if we need it and haven't already generated it.
		if !slices.Contains(g.reflect.requiredSchemas, schemaName) ||
			slices.Contains(g.generatedSchemas, schemaName) {
			continue
		}

		typeName := fullMessageTypeName(message.Desc)
		messageDescription := g.filterCommentString(message.Comments.Leading)

		// `google.protobuf.Value` and `google.protobuf.Any` have special JSON transcoding
		// so we can't just reflect on the message descriptor.
		if typeName == ".google.protobuf.Value" {
			g.addSchemaToDocumentV3(d, wk.NewGoogleProtobufValueSchema(schemaName))
			continue
		} else if typeName == ".google.protobuf.Any" {
			g.addSchemaToDocumentV3(d, wk.NewGoogleProtobufAnySchema(schemaName))
			continue
		} else if typeName == ".google.rpc.Status" {
			anySchemaName := formatMessageName(anyProtoDesc)
			g.addSchemaToDocumentV3(d, wk.NewGoogleProtobufAnySchema(anySchemaName))
			g.addSchemaToDocumentV3(d, wk.NewGoogleRpcStatusSchema(schemaName, anySchemaName))
			continue
		}

		// Build an array holding the fields of the message.
		definitionProperties := &v3.Properties{
			AdditionalProperties: make([]*v3.NamedSchemaOrReference, 0),
		}

		var required []string
		for _, field := range message.Fields {
			// Get the field description from the comments.
			description := g.filterCommentString(field.Comments.Leading)
			// Check the field annotations to see if this is a readonly or writeonly field.
			inputOnly := false
			outputOnly := false
			extension := proto.GetExtension(field.Desc.Options(), annotations.E_FieldBehavior)
			if extension != nil {
				switch v := extension.(type) {
				case []annotations.FieldBehavior:
					for _, vv := range v {
						switch vv {
						case annotations.FieldBehavior_OUTPUT_ONLY:
							outputOnly = true
						case annotations.FieldBehavior_INPUT_ONLY:
							inputOnly = true
						case annotations.FieldBehavior_REQUIRED:
							required = append(required, formatFieldName(field.Desc))
						}
					}
				default:
					log.Printf("unsupported extension type %T", extension)
				}
			}

			// The field is either described by a reference or a schema.
			fieldSchema := g.reflect.schemaOrReferenceForField(field.Desc)
			if fieldSchema == nil {
				continue
			}

			// If this field has siblings and is a $ref now, create a new schema use `allOf` to wrap it
			wrapperNeeded := inputOnly || outputOnly || description != ""
			if wrapperNeeded {
				if _, ok := fieldSchema.Oneof.(*v3.SchemaOrReference_Reference); ok {
					fieldSchema = &v3.SchemaOrReference{Oneof: &v3.SchemaOrReference_Schema{Schema: &v3.Schema{
						AllOf: []*v3.SchemaOrReference{fieldSchema},
					}}}
				}
			}

			if schema, ok := fieldSchema.Oneof.(*v3.SchemaOrReference_Schema); ok {
				schema.Schema.Description = description
				schema.Schema.ReadOnly = outputOnly
				schema.Schema.WriteOnly = inputOnly

				// Merge any `Property` annotations with the current
				extProperty := proto.GetExtension(field.Desc.Options(), v3.E_Property)
				if extProperty != nil {
					proto.Merge(schema.Schema, extProperty.(*v3.Schema))
				}
			}

			definitionProperties.AdditionalProperties = append(
				definitionProperties.AdditionalProperties,
				&v3.NamedSchemaOrReference{
					Name:  formatFieldName(field.Desc),
					Value: fieldSchema,
				},
			)
		}

		schema := &v3.Schema{
			Type:        "object",
			Description: messageDescription,
			Properties:  definitionProperties,
			Required:    required,
		}

		// Merge any `Schema` annotations with the current
		extSchema := proto.GetExtension(message.Desc.Options(), v3.E_Schema)
		if extSchema != nil {
			proto.Merge(schema, extSchema.(*v3.Schema))
		}

		// Add the schema to the components.schema list.
		g.addSchemaToDocumentV3(d, &v3.NamedSchemaOrReference{
			Name: schemaName,
			Value: &v3.SchemaOrReference{
				Oneof: &v3.SchemaOrReference_Schema{
					Schema: schema,
				},
			},
		})
	}
}

package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"github.com/go-leo/gors/cmd/internal"
	"github.com/go-leo/gors/internal/pkg/parser"
	"github.com/go-leo/gox/slicex"
	"github.com/go-leo/gox/stringx"
	"go/ast"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"strings"
)

var (
	serviceName = flag.String("service", "", "service interface Name; must be set")
	pathToLower = flag.Bool("path_to_lower", false, "make path to lower case")
)

// Usage is a replacement usage function for the flags package.
func Usage() {
	fmt.Fprintf(os.Stderr, "Usage of gors:\n")
	fmt.Fprintf(os.Stderr, "\tgors -service S\n")
	fmt.Fprintf(os.Stderr, "Flags:\n")
	flag.PrintDefaults()
}

func init() {
	log.SetFlags(0)
	log.SetPrefix("gors: ")
}

func main() {
	showVersion := flag.Bool("version", false, "print the version and exit")
	flag.Usage = Usage
	flag.Parse()
	if *showVersion {
		fmt.Printf("gors %v\n", internal.Version)
		return
	}

	// must set service names
	if len(*serviceName) == 0 {
		flag.Usage()
		os.Exit(2)
	}
	// We accept either one directory or a list of files. Which do we have?
	args := flag.Args()
	if len(args) == 0 {
		// Default: process whole package in current directory.
		args = []string{"."}
	}

	// load package information
	pkg, err := parser.LoadPkg(args)
	if err != nil {
		log.Fatal(err)
	}
	pkgName := pkg.Name
	goFiles := pkg.GoFiles
	pkgPath := pkg.PkgPath

	// Inspect package
	serviceFile, serviceDecl, serviceSpec, serviceType, serviceMethods := parser.Inspect(pkg, *serviceName)
	if serviceFile == nil || serviceDecl == nil || serviceSpec == nil || serviceType == nil {
		log.Fatal("error: not found service")
	}
	imports := parser.ExtractGoImports(serviceFile)

	var serviceInfo *parser.ServiceInfo
	Param2s := make(map[*parser.RouterInfo]*parser.Param)
	Result1s := make(map[*parser.RouterInfo]*parser.Result)
	if serviceDecl != nil && serviceSpec != nil && serviceType != nil && len(serviceMethods) > 0 {
		// find basePath
		serviceInfo = parser.InitServiceInfo(*serviceName, serviceDecl)
		// generate router by method comment
		for _, method := range serviceMethods {
			if slicex.IsEmpty(method.Names) {
				continue
			}
			methodName := method.Names[0]
			rpcType, ok := method.Type.(*ast.FuncType)
			if !ok {
				log.Fatalf("error: func %s not convert to *ast.FuncType", methodName)
			}
			// params
			param2, err := parser.CheckParams(rpcType, methodName, imports)
			if err != nil {
				log.Fatal(err)
			}

			// results
			result1, err := parser.CheckResults(rpcType, methodName, imports)
			if err != nil {
				log.Fatal(err)
			}

			fmName := FullMethodName(pkgName, serviceInfo, methodName)
			var routerInfo *parser.RouterInfo
			if method.Doc == nil {
				routerInfo = parser.NewRouter(methodName.String(), fmName, nil)
			} else {
				comments := slicex.Map[[]*ast.Comment, []string](
					method.Doc.List,
					func(i int, e1 *ast.Comment) string { return e1.Text },
				)
				routerInfo = parser.NewRouter(methodName.String(), fmName, comments)
			}
			Param2s[routerInfo] = param2
			Result1s[routerInfo] = result1
			routerInfo.FuncType = rpcType

			if stringx.IsBlank(routerInfo.HttpMethod) {
				routerInfo.HttpMethod = parser.GET
			}
			if stringx.IsBlank(routerInfo.Path) {
				routerInfo.Path = routerInfo.FullMethodName
				if *pathToLower {
					routerInfo.Path = strings.ToLower(routerInfo.Path)
				}
			}
			defaultBindingName(routerInfo, param2)
			defaultRenderName(routerInfo, result1)
			routerInfo.HandlerName = handlerName(routerInfo, serviceInfo)
			serviceInfo.Routers = append(serviceInfo.Routers, routerInfo)
		}
	}

	g := &generate{
		buf:              &bytes.Buffer{},
		headerBuf:        &bytes.Buffer{},
		importsBuf:       &bytes.Buffer{},
		functionBuf:      &bytes.Buffer{},
		header:           fmt.Sprintf(`// Code generated by "gors %s"; DO NOT EDIT.`, strings.Join(os.Args[1:], " ")),
		pkgName:          pkgName,
		imports:          imports,
		usedPackageNames: make(map[string]bool),
		serviceInfo:      serviceInfo,
		Param2s:          Param2s,
		Result1s:         Result1s,
	}

	content := g.content()
	// Format the output.
	src, err := format.Source(content)
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		src = content
	}

	// Write to file.
	outDir, err := detectOutputDir(goFiles)
	if err != nil {
		log.Fatalf("error: detect output dir: %s", err)
	}
	outputPath := filepath.Join(outDir, fmt.Sprintf("%s_gors.go", strings.ToLower(*serviceName)))

	if err := os.WriteFile(outputPath, src, 0644); err != nil {
		log.Fatalf("writing output: %s", err)
	}
	log.Printf("%s.%s wrote %s", pkgPath, *serviceName, outputPath)
}

func FullMethodName(pkgName string, serviceInfo *parser.ServiceInfo, methodName *ast.Ident) string {
	return fmt.Sprintf("/%s.%s/%s", pkgName, serviceInfo.Name, methodName.String())
}

func detectOutputDir(paths []string) (string, error) {
	if len(paths) == 0 {
		return "", errors.New("no files to derive output directory from")
	}
	dir := filepath.Dir(paths[0])
	for _, p := range paths[1:] {
		if dir2 := filepath.Dir(p); dir2 != dir {
			return "", fmt.Errorf("found conflicting directories %q and %q", dir, dir2)
		}
	}
	return dir, nil
}

func defaultBindingName(info *parser.RouterInfo, Param2 *parser.Param) {
	if Param2.Reader {
		if slicex.IsEmpty(info.Bindings) {
			info.Bindings = []string{
				parser.ReaderBinding,
			}
		}
	} else if Param2.Bytes {
		if slicex.IsEmpty(info.Bindings) {
			info.Bindings = []string{
				parser.BytesBinding,
			}
		}
	} else if Param2.String {
		if slicex.IsEmpty(info.Bindings) {
			info.Bindings = []string{
				parser.StringBinding,
			}
		}
	} else if objectArgs := Param2.ObjectArgs; objectArgs != nil {
		if slicex.IsEmpty(info.Bindings) {
			info.Bindings = []string{parser.QueryBinding}
			info.BindingContentType = ""
		}
	} else {
		log.Fatalf("error: func %s 2th param is invalid, must be []byte or string or *struct{}", info.FullMethodName)
	}
}

func defaultRenderName(info *parser.RouterInfo, Result1 *parser.Result) {
	switch {
	case Result1.Bytes:
		if stringx.IsBlank(info.Render) {
			info.Render = parser.BytesRender
		}
	case Result1.String:
		if stringx.IsBlank(info.Render) {
			info.Render = parser.StringRender
		}
	case Result1.Reader:
		if stringx.IsBlank(info.Render) {
			info.Render = parser.ReaderRender
		}
	case Result1.ObjectArgs != nil:
		if stringx.IsBlank(info.Render) {
			info.Render = parser.JSONRender
			info.RenderContentType = parser.JSONContentType
		}
	default:
		log.Fatalf("error: func %s 1th result is invalid, must be io.Reader or []byte or string or *struct{}", info.FullMethodName)
	}
}

package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"github.com/go-leo/gors/cmd/internal"
	"github.com/go-leo/gors/internal/pkg/parser"
	"github.com/go-leo/gox/slicex"
	"github.com/go-leo/gox/stringx"
	"go/ast"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"strings"
)

var (
	serviceName = flag.String("service", "", "service interface Name; must be set")
	pathToLower = flag.Bool("path_to_lower", false, "make path to lower case")
)

// Usage is a replacement usage function for the flags package.
func Usage() {
	fmt.Fprintf(os.Stderr, "Usage of gors:\n")
	fmt.Fprintf(os.Stderr, "\tgors -service S\n")
	fmt.Fprintf(os.Stderr, "Flags:\n")
	flag.PrintDefaults()
}

func init() {
	log.SetFlags(0)
	log.SetPrefix("gors: ")
}

func main() {
	showVersion := flag.Bool("version", false, "print the version and exit")
	flag.Usage = Usage
	flag.Parse()
	if *showVersion {
		fmt.Printf("gors %v\n", internal.Version)
		return
	}

	// must set service names
	if len(*serviceName) == 0 {
		flag.Usage()
		os.Exit(2)
	}
	// We accept either one directory or a list of files. Which do we have?
	args := flag.Args()
	if len(args) == 0 {
		// Default: process whole package in current directory.
		args = []string{"."}
	}

	// load package information
	pkg, err := parser.LoadPkg(args)
	if err != nil {
		log.Fatal(err)
	}
	pkgName := pkg.Name
	goFiles := pkg.GoFiles
	pkgPath := pkg.PkgPath

	// Inspect package
	serviceFile, serviceDecl, serviceSpec, serviceType, serviceMethods := parser.Inspect(pkg, *serviceName)
	if serviceFile == nil || serviceDecl == nil || serviceSpec == nil || serviceType == nil {
		log.Fatal("error: not found service")
	}
	// find basePath
	serviceInfo := parser.InitServiceInfo(*serviceName, serviceDecl)
	imports := parser.ExtractGoImports(serviceFile)

	// generate router by method comment
	for _, method := range serviceMethods {
		if slicex.IsEmpty(method.Names) {
			continue
		}
		methodName := method.Names[0]
		rpcType, ok := method.Type.(*ast.FuncType)
		if !ok {
			log.Fatalf("error: func %s not convert to *ast.FuncType", methodName)
		}
		// params
		param2, err := parser.CheckParams(rpcType, methodName, imports)
		if err != nil {
			log.Fatal(err)
		}

		// results
		result1, err := parser.CheckResults(rpcType, methodName, imports)
		if err != nil {
			log.Fatal(err)
		}
		routerInfo := parser.ExtractRouterInfo(method, methodName)
		routerInfo.SetHandlerName(serviceInfo)
		routerInfo.SetFullMethodName(FullMethodName(pkgName, serviceInfo, methodName))
		routerInfo.SetFuncType(rpcType)
		routerInfo.SetParam2(param2)
		routerInfo.SetResult1(result1)
		DefaultHttpMethod(routerInfo)
		DefaultHttpPath(routerInfo)
		DefaultBindingName(routerInfo, param2)
		DefaultRenderName(routerInfo, result1)
		serviceInfo.Routers = append(serviceInfo.Routers, routerInfo)
	}

	g := &generate{
		buf:              &bytes.Buffer{},
		headerBuf:        &bytes.Buffer{},
		importsBuf:       &bytes.Buffer{},
		functionBuf:      &bytes.Buffer{},
		header:           fmt.Sprintf(`// Code generated by "gors %s"; DO NOT EDIT.`, strings.Join(os.Args[1:], " ")),
		pkgName:          pkgName,
		imports:          imports,
		usedPackageNames: make(map[string]bool),
		serviceInfo:      serviceInfo,
	}

	content := g.content()
	// Format the output.
	src, err := format.Source(content)
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		src = content
	}

	// Write to file.
	outDir, err := detectOutputDir(goFiles)
	if err != nil {
		log.Fatalf("error: detect output dir: %s", err)
	}
	outputPath := filepath.Join(outDir, fmt.Sprintf("%s_gors.go", strings.ToLower(*serviceName)))

	if err := os.WriteFile(outputPath, src, 0644); err != nil {
		log.Fatalf("writing output: %s", err)
	}
	log.Printf("%s.%s wrote %s", pkgPath, *serviceName, outputPath)
}

func DefaultHttpMethod(routerInfo *parser.RouterInfo) {
	if stringx.IsBlank(routerInfo.HttpMethod) {
		routerInfo.HttpMethod = parser.GET
	}
}

func DefaultHttpPath(routerInfo *parser.RouterInfo) {
	if stringx.IsBlank(routerInfo.Path) {
		routerInfo.Path = routerInfo.FullMethodName
		if *pathToLower {
			routerInfo.Path = strings.ToLower(routerInfo.Path)
		}
	}
}

func DefaultBindingName(info *parser.RouterInfo, Param2 *parser.Param) {
	if Param2.Reader {
		if slicex.IsEmpty(info.Bindings) {
			info.Bindings = []string{
				parser.ReaderBinding,
			}
		}
	} else if Param2.Bytes {
		if slicex.IsEmpty(info.Bindings) {
			info.Bindings = []string{
				parser.BytesBinding,
			}
		}
	} else if Param2.String {
		if slicex.IsEmpty(info.Bindings) {
			info.Bindings = []string{
				parser.StringBinding,
			}
		}
	} else if objectArgs := Param2.ObjectArgs; objectArgs != nil {
		if slicex.IsEmpty(info.Bindings) {
			info.Bindings = []string{parser.QueryBinding}
			info.BindingContentType = ""
		}
	} else {
		log.Fatalf("error: func %s 2th param is invalid, must be []byte or string or *struct{}", info.FullMethodName)
	}
}

func DefaultRenderName(info *parser.RouterInfo, Result1 *parser.Result) {
	switch {
	case Result1.Bytes:
		if stringx.IsBlank(info.Render) {
			info.Render = parser.BytesRender
		}
	case Result1.String:
		if stringx.IsBlank(info.Render) {
			info.Render = parser.StringRender
		}
	case Result1.Reader:
		if stringx.IsBlank(info.Render) {
			info.Render = parser.ReaderRender
		}
	case Result1.ObjectArgs != nil:
		if stringx.IsBlank(info.Render) {
			info.Render = parser.JSONRender
			info.RenderContentType = parser.JSONContentType
		}
	default:
		log.Fatalf("error: func %s 1th result is invalid, must be io.Reader or []byte or string or *struct{}", info.FullMethodName)
	}
}

func FullMethodName(pkgName string, serviceInfo *parser.ServiceInfo, methodName *ast.Ident) string {
	return fmt.Sprintf("/%s.%s/%s", pkgName, serviceInfo.Name, methodName.String())
}

func detectOutputDir(paths []string) (string, error) {
	if len(paths) == 0 {
		return "", errors.New("no files to derive output directory from")
	}
	dir := filepath.Dir(paths[0])
	for _, p := range paths[1:] {
		if dir2 := filepath.Dir(p); dir2 != dir {
			return "", fmt.Errorf("found conflicting directories %q and %q", dir, dir2)
		}
	}
	return dir, nil
}

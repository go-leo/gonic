package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"log"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/go-leo/osx/filex"
	"github.com/go-leo/slicex"
	"github.com/go-leo/stringx"
	"golang.org/x/tools/go/packages"

	"github.com/go-leo/gors/internal/pkg/annotation"
)

//var anno = regexp.MustCompile(`^\S*@GORS\S*(@BasePath\("(.*)?"\))?\s*$`)

var (
	serviceName = flag.String("service", "Add", "service interface name; must be set")
	output      = flag.String("output", "", "output file name; default srcdir/<service>_gors.go")
	buildTags   = flag.String("tags", "", "comma-separated list of build tags to apply")
)

// Usage is a replacement usage function for the flags package.
func Usage() {
	fmt.Fprintf(os.Stderr, "Usage of gors:\n")
	fmt.Fprintf(os.Stderr, "\tgors [flags] -service S [directory]\n")
	fmt.Fprintf(os.Stderr, "\tgors [flags] -service S files... # Must be a single package\n")
	fmt.Fprintf(os.Stderr, "Flags:\n")
	flag.PrintDefaults()
}

func main() {
	log.SetFlags(log.LstdFlags | log.Lshortfile)
	log.SetPrefix("gors: ")

	flag.Usage = Usage
	flag.Parse()

	// must set service names
	if len(*serviceName) == 0 {
		flag.Usage()
		os.Exit(2)
	}

	srvName := *serviceName

	// build tag
	var tags []string
	if len(*buildTags) > 0 {
		tags = strings.Split(*buildTags, ",")
	}

	// We accept either one directory or a list of files. Which do we have?
	args := flag.Args()

	if len(args) == 0 {
		// Default: process whole package in current directory.
		args = []string{"."}
	}

	// Parse the package once.
	var dir string
	if len(args) == 1 && filex.IsDirectory(args[0]) {
		dir = args[0]
	} else {
		if len(tags) != 0 {
			log.Fatal("-tags option applies only to directories, not when files are specified")
		}
		dir = filepath.Dir(args[0])
	}

	// load all package information
	cfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedFiles | packages.NeedCompiledGoFiles |
			packages.NeedImports | packages.NeedDeps | packages.NeedExportFile | packages.NeedTypes |
			packages.NeedSyntax | packages.NeedTypesInfo | packages.NeedTypesSizes,
		BuildFlags: []string{fmt.Sprintf("-tags=%s", strings.Join(tags, " "))},
	}
	pkgs, err := packages.Load(cfg, args...)
	if err != nil {
		log.Fatal(err)
	}
	if len(pkgs) != 1 {
		log.Fatalf("error: %d packages found", len(pkgs))
	}
	pkg := pkgs[0]

	var buf bytes.Buffer

	// Print the header and package clause.
	fmt.Fprintf(&buf, "// Code generated by \"gors %s\"; DO NOT EDIT.\n", strings.Join(os.Args[1:], " "))
	fmt.Fprintf(&buf, "\n")
	fmt.Fprintf(&buf, "package %s", pkg.Name)
	fmt.Fprintf(&buf, "\n")

	// Print imports
	fmt.Fprintf(&buf, "import (\n")
	fmt.Fprintf(&buf, "\t\"net/http\"\n")
	fmt.Fprintf(&buf, "\n")
	fmt.Fprintf(&buf, "\t\"github.com/gin-gonic/gin\"\n")
	fmt.Fprintf(&buf, "\t\"github.com/go-leo/gors\"\n")
	fmt.Fprintf(&buf, ")\n")

	fmt.Fprintf(&buf, "func %sRouters(srv %s) []gors.Router {\n", srvName, srvName)
	fmt.Fprintf(&buf, "\treturn []gors.Router{\n")

	var serviceDecl *ast.GenDecl
	var serviceSpec *ast.TypeSpec
	var serviceType *ast.InterfaceType
	var serviceMethods []*ast.Field
	for _, file := range pkg.Syntax {
		ast.Inspect(file, func(node ast.Node) bool {
			if node == nil {
				return true
			}
			denDecl, ok := node.(*ast.GenDecl)
			if !ok {
				return true
			}
			if denDecl.Tok != token.TYPE {
				// We only care about type declarations.
				return true
			}
			for _, spec := range denDecl.Specs {
				typeSpec, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}
				interfaceType, ok := typeSpec.Type.(*ast.InterfaceType)
				if !ok {
					continue
				}
				if typeSpec.Name.Name != *serviceName {
					// This is not the interface type we're looking for.
					continue
				}
				serviceDecl = denDecl
				serviceSpec = typeSpec
				serviceType = interfaceType
				serviceMethods = interfaceType.Methods.List
				return false
			}
			return true
		})
	}

	var basePath string
	var globalConsume string
	var globalProduce string
	if serviceDecl != nil && serviceSpec != nil && serviceType != nil && len(serviceMethods) > 0 {
		// find basePath\globalConsume\globalProduce
		for _, comment := range serviceDecl.Doc.List {
			text := strings.TrimSpace(strings.TrimPrefix(strings.TrimSpace(comment.Text), "//"))
			seg := strings.Split(text, " ")
			if seg[0] != annotation.GORS {
				continue
			}
			for _, s := range seg {
				s = strings.TrimSpace(s)
				switch {
				case strings.HasPrefix(s, annotation.Path):
					v, ok := findPath(s)
					if !ok {
						log.Fatalf("error: %s path invalid", s)
					}
					basePath = path.Join(basePath, v)
				case strings.HasPrefix(s, annotation.Consume):
					v, ok := findConsume(s)
					if !ok {
						log.Fatalf("error: %s comsume invalid", s)
					}
					globalConsume = v
				case strings.HasPrefix(s, annotation.Produce):
					v, ok := findProduce(s)
					if !ok {
						log.Fatalf("error: %s produce invalid", s)
					}
					globalProduce = v
				case strings.HasPrefix(s, annotation.GORS):
				case "" == s:
				default:
					log.Printf("warning: format error: unsupport: %s", s)
				}
			}
		}

		// generate router by method comment
		for _, method := range serviceMethods {
			if method.Doc == nil && len(method.Doc.List) <= 0 {
				continue
			}
			router := newRouter(basePath, globalConsume, globalProduce, method.Doc.List)
			if router == nil {
				continue
			}
			if slicex.IsEmpty(method.Names) {
				continue
			}
			methodName := method.Names[0]

			rpcType, ok := method.Type.(*ast.FuncType)
			if !ok {
				log.Fatalf("error: func %s not convert to *ast.FuncType", methodName)
			}

			// params
			if rpcType.Params == nil {
				log.Fatalf("error: func %s params is empty", methodName)
			}
			if len(rpcType.Params.List) != 2 {
				log.Fatalf("error: func %s params count is not equal 2", methodName)
			}

			// param0
			param0 := rpcType.Params.List[0]
			param0SelectorExpr, ok := param0.Type.(*ast.SelectorExpr)
			if !ok {
				log.Fatalf("error: func %s 1th param is not context.Context", methodName)
			}
			if param0SelectorExpr.Sel.Name != "Context" {
				log.Fatalf("error: func %s 1th param is not context.Context", methodName)
			}
			param0SelectorExprX, ok := param0SelectorExpr.X.(*ast.Ident)
			if !ok {
				log.Fatalf("error: func %s 1th param is not context.Context", methodName)
			}
			if param0SelectorExprX.Name != "context" {
				log.Fatalf("error: func %s 1th param is not context.Context", methodName)
			}

			// param1
			param1 := rpcType.Params.List[1]
			var startParam1 *ast.StarExpr
			var identParam1 *ast.Ident
			var arrayParam1 *ast.ArrayType
			switch p1 := param1.Type.(type) {
			case *ast.ArrayType:
				arrayParam1 = p1
				ident, ok := arrayParam1.Elt.(*ast.Ident)
				if !ok {
					log.Fatalf("error: func %s 2th param is invalid, must be []byte or string or *struct{}", methodName)
				}
				if ident.Name != "byte" {
					log.Fatalf("error: func %s 2th param is invalid, must be []byte or string or *struct{}", methodName)
				}
			case *ast.Ident:
				identParam1 = p1
			case *ast.StarExpr:
				startParam1 = p1
			default:
				log.Fatalf("error: func %s 2th param is invalid, must be []byte or string or *struct{}", methodName)
			}

			fmt.Println(startParam1, identParam1, arrayParam1)

			if rpcType.Results == nil {
				log.Fatalf("error: func %s results is empty", methodName)
			}
			if len(rpcType.Results.List) != 2 {
				log.Fatalf("error: func %s results count is not equal 2", methodName)
			}

			// result0

			// result1
			result1 := rpcType.Results.List[1]

			fmt.Println(result1)

			fmt.Fprintf(&buf, "\t\t{\n")
			fmt.Fprintf(&buf, "\t\t\tHTTPMethods: []string{%s},\n", strings.Join(router.method, ","))
			fmt.Fprintf(&buf, "\t\t\tPath:        \"%s\",\n", router.path)
			fmt.Fprintf(&buf, "\t\t\tHandlerFuncs: []gin.HandlerFunc{\n")
			fmt.Fprintf(&buf, "\t\t\t\tfunc(c *gin.Context) {\n")
			if arrayParam1 != nil {
				fmt.Fprintf(&buf, "\t\t\t\treq, err := io.ReadAll(c.Request.Body)\n")
				fmt.Fprintf(&buf, "\t\t\t\tif err != nil {\n")
				fmt.Fprintf(&buf, "\t\t\t\t\tc.Abort()\n")
				fmt.Fprintf(&buf, "\t\t\t\t\tc.String(http.StatusBadRequest, err.Error())\n")
				fmt.Fprintf(&buf, "\t\t\t\t\treturn\n")
				fmt.Fprintf(&buf, "\t\t\t\t}\n")
			} else if identParam1 != nil {

			} else if startParam1 != nil {
				switch startParam1.X.(type) {
				case *ast.Ident:
				case *ast.StarExpr:

				}
				startParam1X, ok := startParam1.X.(*ast.Ident)
				if !ok {
					log.Fatalf("error: func %s 2th param is invalid", methodName)
				}
				fmt.Fprintf(&buf, "\t\t\t\t\treq := new(%s)\n", startParam1X.Name)
			} else {
				log.Fatalf("error: func %s 2th param is invalid, must be []byte or string or *struct{}", methodName)
			}

			// call rpc
			fmt.Fprintf(&buf, "\t\t\t\tresp, err := srv.%s(c.Request.Context(), req)\n", methodName)

			// error handle
			fmt.Fprintf(&buf, "\t\t\t\tif err != nil {\n")
			fmt.Fprintf(&buf, "\t\t\t\t\tif httpErr, ok := err.(*gors.HttpError); ok {\n")
			fmt.Fprintf(&buf, "\t\t\t\t\t\tc.Abort()\n")
			fmt.Fprintf(&buf, "\t\t\t\t\t\tc.String(httpErr.StatusCode(), httpErr.Error())\n")
			fmt.Fprintf(&buf, "\t\t\t\t\t} else {\n")
			fmt.Fprintf(&buf, "\t\t\t\t\t\tc.Abort()\n")
			fmt.Fprintf(&buf, "\t\t\t\t\t\tc.String(http.StatusInternalServerError, err.Error())\n")
			fmt.Fprintf(&buf, "\t\t\t\t\t}\n")
			fmt.Fprintf(&buf, "\t\t\t\t\treturn\n")
			fmt.Fprintf(&buf, "\t\t\t\t}\n")

			// reply
			switch strings.ToLower(router.produce) {
			case "html":
				fmt.Fprintf(&buf, "\t\t\t\t\tc.Data(http.StatusOK, \"text/html; charset=utf-8\",\"resp\")\n")

			}

			fmt.Fprintf(&buf, "\t\t\t\t},\n")
			fmt.Fprintf(&buf, "\t\t\t},\n")
			fmt.Fprintf(&buf, "\t\t},\n")
		}
	}

	fmt.Println(basePath, globalConsume, globalProduce)

	fmt.Fprintf(&buf, "\t}\n")
	fmt.Fprintf(&buf, "}\n")

	// Format the output.
	var src []byte
	src, err = format.Source(buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		src = buf.Bytes()
	}

	// Write to file.
	outputName := *output
	if outputName == "" {
		baseName := fmt.Sprintf("%s_gors.go", srvName)
		outputName = filepath.Join(dir, strings.ToLower(baseName))
	}

	if err := os.WriteFile(outputName, src, 0644); err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

func newRouter(basePath string, globalConsume string, globalProduce string, commentList []*ast.Comment) *router {
	var r *router
	for _, comment := range commentList {
		text := strings.TrimSpace(strings.TrimPrefix(strings.TrimSpace(comment.Text), "//"))
		seg := strings.Split(text, " ")
		if seg[0] != annotation.GORS {
			continue
		}
		if r == nil {
			r = &router{}
		}
		for _, s := range seg {
			s = strings.TrimSpace(s)
			switch {
			case strings.HasPrefix(s, annotation.Path):
				v, ok := findPath(s)
				if !ok {
					log.Fatalf("error: %s path invalid", s)
				}
				r.path = path.Join(r.path, v)
			case strings.HasPrefix(s, annotation.Consume):
				v, ok := findConsume(s)
				if !ok {
					log.Fatalf("error: %s produce invalid", s)
				}
				r.consume = v
			case strings.HasPrefix(s, annotation.Produce):
				v, ok := findProduce(s)
				if !ok {
					log.Fatalf("error: %s produce invalid", s)
				}
				r.produce = v
			case strings.HasPrefix(s, annotation.Method):
				methods, ok := findMethods(s)
				if !ok {
					log.Fatalf("error: %s method invalid", s)
				}
				r.method = append(r.method, methods...)
			case s == annotation.GET:
				r.method = append(r.method, "http.MethodGet")
			case s == annotation.HEAD:
				r.method = append(r.method, "http.MethodHead")
			case s == annotation.POST:
				r.method = append(r.method, "http.MethodPost")
			case s == annotation.PUT:
				r.method = append(r.method, "http.MethodPut")
			case s == annotation.PATCH:
				r.method = append(r.method, "http.MethodPatch")
			case s == annotation.DELETE:
				r.method = append(r.method, "http.MethodDelete")
			case s == annotation.CONNECT:
				r.method = append(r.method, "http.MethodConnect")
			case s == annotation.OPTIONS:
				r.method = append(r.method, "http.MethodOptions")
			case s == annotation.TRACE:
				r.method = append(r.method, "http.MethodTrace")
			case s == annotation.PathParam:
				r.pathParam = true
			case s == annotation.QueryParam:
				r.queryParam = true
			case s == annotation.HeaderParam:
				r.headerParam = true
			case s == annotation.BodyParam:
				r.bodyParam = true
			case strings.HasPrefix(s, annotation.GORS):
			case "" == s:
			default:
				log.Printf("warning: format error: unsupport: %s", s)
			}
		}
	}
	if r != nil {
		r.method = slicex.Uniq(r.method)
		r.path = path.Join(basePath, r.path)
		if stringx.IsBlank(r.consume) {
			r.consume = globalConsume
		}
		if stringx.IsBlank(r.produce) {
			r.produce = globalProduce
		}
	}
	return r
}

func findPath(s string) (string, bool) {
	reg := regexp.MustCompile(`@Path\("(.*)"\)`)
	if !reg.MatchString(s) {
		return "", false
	}
	matchArr := reg.FindStringSubmatch(s)
	return matchArr[len(matchArr)-1], true
}

func findProduce(s string) (string, bool) {
	reg := regexp.MustCompile(`@Produce\("(.*)"\)`)
	if !reg.MatchString(s) {
		return "", false
	}
	matchArr := reg.FindStringSubmatch(s)
	return matchArr[len(matchArr)-1], true
}

func findConsume(s string) (string, bool) {
	reg := regexp.MustCompile(`@Consume\("(.*)"\)`)
	if !reg.MatchString(s) {
		return "", false
	}
	matchArr := reg.FindStringSubmatch(s)
	return matchArr[len(matchArr)-1], true
}

func findMethods(s string) ([]string, bool) {
	reg := regexp.MustCompile(`@Method\("(.*)"\)`)
	if !reg.MatchString(s) {
		return nil, false
	}
	matchArr := reg.FindStringSubmatch(s)
	val := matchArr[len(matchArr)-1]
	if val == "*" {
		return []string{
			"http.MethodGet",
			"http.MethodHead",
			"http.MethodPost",
			"http.MethodPut",
			"http.MethodPatch",
			"http.MethodDelete",
			"http.MethodConnect",
			"http.MethodOptions",
			"http.MethodTrace",
		}, true
	}
	seg := strings.Split(val, ",")
	res := make([]string, 0, len(seg))
	for _, s := range seg {
		switch strings.ToUpper(s) {
		case "GET":
			res = append(res, "http.MethodGet")
		case "HEAD":
			res = append(res, "http.MethodHead")
		case "POST":
			res = append(res, "http.MethodPost")
		case "PUT":
			res = append(res, "http.MethodPut")
		case "PATCH":
			res = append(res, "http.MethodPatch")
		case "DELETE":
			res = append(res, "http.MethodDelete")
		case "CONNECT":
			res = append(res, "http.MethodConnect")
		case "OPTIONS":
			res = append(res, "http.MethodOptions")
		case "TRACE":
			res = append(res, "http.MethodTrace")
		}
	}
	return res, true
}

type router struct {
	method      []string
	path        string
	consume     string
	produce     string
	pathParam   bool
	queryParam  bool
	headerParam bool
	bodyParam   bool
}
